{
  "repo_name": "sindresorhus_promise-fun",
  "readme_content": "# promise-fun\n\nI intend to use this space to document my promise modules, useful promise patterns, and how to solve common problems. For now though, you can see all my promise modules below.\n\n## Contents\n\n- [Packages](#packages)\n- [FAQ](#faq)\n\n## Packages\n\n*Not accepting additions, but happy to take requests.*\n\n- **[pify](https://github.com/sindresorhus/pify)**: Promisify a callback-style function\n- **[delay](https://github.com/sindresorhus/delay)**: Delay a promise a specified amount of time\n- **[yoctodelay](https://github.com/sindresorhus/yoctodelay)**: Delay a promise a specified amount of time\n- **[p-map](https://github.com/sindresorhus/p-map)**: Map over promises concurrently\n- **[p-all](https://github.com/sindresorhus/p-all)**: Run promise-returning & async functions concurrently with optional limited concurrency\n- **[p-queue](https://github.com/sindresorhus/p-queue)**: Promise queue with concurrency control\n- **[p-event](https://github.com/sindresorhus/p-event)**: Promisify an event by waiting for it to be emitted\n- **[p-debounce](https://github.com/sindresorhus/p-debounce)**: Debounce promise-returning & async functions\n- **[p-throttle](https://github.com/sindresorhus/p-throttle)**: Throttle promise-returning & async functions\n- **[p-timeout](https://github.com/sindresorhus/p-timeout)**: Timeout a promise after a specified amount of time\n- **[p-retry](https://github.com/sindresorhus/p-retry)**: Retry a promise-returning or async function\n- **[p-any](https://github.com/sindresorhus/p-any)**: Wait for any promise to be fulfilled\n- **[p-some](https://github.com/sindresorhus/p-some)**: Wait for a specified number of promises to be fulfilled\n- **[p-locate](https://github.com/sindresorhus/p-locate)**: Get the first fulfilled promise that satisfies the provided testing function\n- **[p-limit](https://github.com/sindresorhus/p-limit)**: Run multiple promise-returning & async functions with limited concurrency\n- **[p-series](https://github.com/sindresorhus/p-series)**: Run promise-returning & async functions in series\n- **[p-memoize](https://github.com/sindresorhus/p-memoize)**: Memoize promise-returning & async functions\n- **[p-pipe](https://github.com/sindresorhus/p-pipe)**: Compose promise-returning & async functions into a reusable pipeline\n- **[p-props](https://github.com/sindresorhus/p-props)**: Like `Promise.all()` but for `Map` and `Object`\n- **[p-waterfall](https://github.com/sindresorhus/p-waterfall)**: Run promise-returning & async functions in series, each passing its result to the next\n- **[p-cancelable](https://github.com/sindresorhus/p-cancelable)**: Create a promise that can be canceled\n- **[p-progress](https://github.com/sindresorhus/p-progress)**: Create a promise that reports progress\n- **[p-reflect](https://github.com/sindresorhus/p-reflect)**: Make a promise always fulfill with its actual fulfillment value or rejection reason\n- **[p-filter](https://github.com/sindresorhus/p-filter)**: Filter promises concurrently\n- **[p-reduce](https://github.com/sindresorhus/p-reduce)**: Reduce a list of values using promises into a promise for a value\n- **[p-settle](https://github.com/sindresorhus/p-settle)**: Settle promises concurrently and get their fulfillment value or rejection reason with optional limited concurrency\n- **[p-map-series](https://github.com/sindresorhus/p-map-series)**: Map over promises serially\n- **[p-each-series](https://github.com/sindresorhus/p-each-series)**: Iterate over promises serially\n- **[p-times](https://github.com/sindresorhus/p-times)**: Run promise-returning & async functions a specific number of times concurrently\n- **[p-lazy](https://github.com/sindresorhus/p-lazy)**: Create a lazy promise that defers execution until `.then()` or `.catch()` is called\n- **[p-whilst](https://github.com/sindresorhus/p-whilst)**: While a condition returns true, calls a function repeatedly, and then resolves the promise\n- **[p-do-whilst](https://github.com/sindresorhus/p-do-whilst)**: Calls a function repeatedly while a condition returns true and then resolves the promise\n- **[p-forever](https://github.com/sindresorhus/p-forever)**: Run promise-returning & async functions repeatedly until you end it\n- **[p-wait-for](https://github.com/sindresorhus/p-wait-for)**: Wait for a condition to be true\n- **[p-min-delay](https://github.com/sindresorhus/p-min-delay)**: Delay a promise a minimum amount of time\n- **[p-try](https://github.com/sindresorhus/p-try)**: `Promise.try()` ponyfill - Starts a promise chain\n- **[p-race](https://github.com/sindresorhus/p-race)**: A better `Promise.race()`\n- **[p-immediate](https://github.com/sindresorhus/p-immediate)**: Returns a promise resolved in the next event loop - think `setImmediate()`\n- **[p-time](https://github.com/sindresorhus/p-time)**: Measure the time a promise takes to resolve\n- **[p-defer](https://github.com/sindresorhus/p-defer)**: Create a deferred promise\n- **[p-is-promise](https://github.com/sindresorhus/p-is-promise)**: Check if something is a promise\n- **[p-state](https://github.com/sindresorhus/p-state)**: Inspect the state of a promise\n- **[make-synchronous](https://github.com/sindresorhus/make-synchronous)**: Make an asynchronous function synchronous\n\n### `.then`/`.catch`-based packages\n\n*You should generally avoid using `.then` except in edge cases.*\n\n- **[p-catch-if](https://github.com/sindresorhus/p-catch-if)**: Conditional promise catch handler\n- **[p-if](https://github.com/sindresorhus/p-if)**: Conditional promise chains\n- **[p-tap](https://github.com/sindresorhus/p-tap)**: Tap into a promise chain without affecting its value or state\n- **[p-log](https://github.com/sindresorhus/p-log)**: Log the value/error of a promise\n- **[p-break](https://github.com/sindresorhus/p-break)**: Break out of a promise chain\n\n## FAQ\n\n### How can I run 100 async/promise-returning functions with only 5 running at once?\n\nThis is a good use-case for [`p-map`](https://github.com/sindresorhus/p-map). You might ask why you can't just specify an array of promises. Promises represent values of a computation and not the computation itself - they are eager. So by the time `p-map` starts reading the array, all the actions creating those promises have already started running. `p-map` works by executing a promise-returning function in a mapper function. This way the promises are created lazily and can be concurrency limited. Check out [`p-all`](https://github.com/sindresorhus/p-all) instead if you're using different functions to get each promise.\n\n```js\nimport pMap from 'p-map';\n\nconst urls = [\n\t'https://sindresorhus.com',\n\t'https://avajs.dev',\n\t'https://github.com',\n\t\u2026\n];\n\nconsole.log(urls.length);\n//=> 100\n\nconst mapper = url => fetchStats(url); //=> Promise\n\nconst result = await pMap(urls, mapper, {concurrency: 5});\n\nconsole.log(result);\n//=> [{url: 'https://sindresorhus.com', stats: {\u2026}}, \u2026]\n```\n"
}