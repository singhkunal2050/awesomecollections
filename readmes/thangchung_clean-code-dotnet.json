{
  "repo_name": "thangchung_clean-code-dotnet",
  "readme_content": "# Clean Code concepts adapted for .NET/.NET Core\n\nIf you liked `clean-code-dotnet` project or if it helped you, please give a star :star: for this repository. That will not only help strengthen our .NET community but also improve skills about the clean code for .NET developers in around the world. Thank you very much :+1:\n\nCheck out my [blog](https://medium.com/@thangchung) or say hi on [Twitter](https://twitter.com/thangchung)!\n\n# Table of Contents\n\n- [Clean Code concepts adapted for .NET/.NET Core](#clean-code-concepts-adapted-for-netnet-core)\n- [Table of Contents](#table-of-contents)\n- [Introduction](#introduction)\n- [Clean Code .NET](#clean-code-net)\n  - [Naming](#naming)\n  - [Variables](#variables)\n  - [Functions](#functions)\n  - [Objects and Data Structures](#objects-and-data-structures)\n  - [Classes](#classes)\n  - [SOLID](#solid)\n  - [Testing](#testing)\n  - [Concurrency](#concurrency)\n  - [Error Handling](#error-handling)\n  - [Formatting](#formatting)\n  - [Comments](#comments)\n- [Other Clean Code Resources](#other-clean-code-resources)\n  - [Other Clean Code Lists](#other-clean-code-lists)\n  - [Style Guides](#style-guides)\n  - [Tools](#tools)\n  - [Cheatsheets](#cheatsheets)\n- [Contributors](#contributors)\n- [Backers](#backers)\n- [Sponsors](#sponsors)\n- [License](#license)\n\n# Introduction\n\n![Humorous image of software quality estimation as a count of how many expletives you shout when reading code](http://www.osnews.com/images/comics/wtfm.jpg)\n\nSoftware engineering principles, from Robert C. Martin's book [_Clean Code_](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882), adapted for .NET/.NET Core. This is not a style guide. It's a guide to producing readable, reusable, and refactorable software in .NET/.NET Core.\n\nNot every principle herein has to be strictly followed, and even fewer will be universally agreed upon. These are guidelines and nothing more, but they are ones codified over many years of collective experience by the authors of _Clean Code_.\n\nInspired from [clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript) and [clean-code-php](https://github.com/jupeter/clean-code-php) lists.\n\n# Clean Code .NET\n\n## Naming\n\n<details>\n  <summary><b>Avoid using bad names</b></summary>\nA good name allows the code to be used by many developers. The name should reflect what it does and give context.\n\n**Bad:**\n\n```csharp\nint d;\n```\n\n**Good:**\n\n```csharp\nint daySinceModification;\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid Misleading Names</b></summary>\n\nName the variable to reflect what it is used for.\n\n**Bad:**\n\n```csharp\nvar dataFromDb = db.GetFromService().ToList();\n```\n\n**Good:**\n\n```csharp\nvar listOfEmployee = _employeeService.GetEmployees().ToList();\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid Hungarian notation</b></summary>\n\nHungarian Notation restates the type which is already present in the declaration. This is pointless since modern IDEs will identify the type.\n\n**Bad:**\n\n```csharp\nint iCounter;\nstring strFullName;\nDateTime dModifiedDate;\n```\n\n**Good:**\n\n```csharp\nint counter;\nstring fullName;\nDateTime modifiedDate;\n```\n\nHungarian Notation should also not be used in paramaters.\n\n**Bad:**\n\n```csharp\npublic bool IsShopOpen(string pDay, int pAmount)\n{\n    // some logic\n}\n```\n\n**Good:**\n\n```csharp\npublic bool IsShopOpen(string day, int amount)\n{\n    // some logic\n}\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use consistent capitalization</b></summary>\n\nCapitalization tells you a lot about your variables,\nfunctions, etc. These rules are subjective, so your team can choose whatever\nthey want. The point is, no matter what you all choose, just be consistent.\n\n**Bad:**\n\n```csharp\nconst int DAYS_IN_WEEK = 7;\nconst int daysInMonth = 30;\n\nvar songs = new List<string> { 'Back In Black', 'Stairway to Heaven', 'Hey Jude' };\nvar Artists = new List<string> { 'ACDC', 'Led Zeppelin', 'The Beatles' };\n\nbool EraseDatabase() {}\nbool Restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n```\n\n**Good:**\n\n```csharp\nconst int DaysInWeek = 7;\nconst int DaysInMonth = 30;\n\nvar songs = new List<string> { 'Back In Black', 'Stairway to Heaven', 'Hey Jude' };\nvar artists = new List<string> { 'ACDC', 'Led Zeppelin', 'The Beatles' };\n\nbool EraseDatabase() {}\nbool RestoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use pronounceable names</b></summary>\n\nIt will take time to investigate the meaning of the variables and functions when they are not pronounceable.\n\n**Bad:**\n\n```csharp\npublic class Employee\n{\n    public Datetime sWorkDate { get; set; } // what the heck is this\n    public Datetime modTime { get; set; } // same here\n}\n```\n\n**Good:**\n\n```csharp\npublic class Employee\n{\n    public Datetime StartWorkingDate { get; set; }\n    public Datetime ModificationTime { get; set; }\n}\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use Camelcase notation</b></summary>\n\nUse [Camelcase Notation](https://en.wikipedia.org/wiki/Camel_case) for variable and method paramaters.\n\n**Bad:**\n\n```csharp\nvar employeephone;\n\npublic double CalculateSalary(int workingdays, int workinghours)\n{\n    // some logic\n}\n```\n\n**Good:**\n\n```csharp\nvar employeePhone;\n\npublic double CalculateSalary(int workingDays, int workingHours)\n{\n    // some logic\n}\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use domain name</b></summary>\n\nPeople who read your code are also programmers. Naming things right will help everyone be on the same page. We don't want to take time to explain to everyone what a variable or function is for.\n\n**Good**\n\n```csharp\npublic class SingleObject\n{\n    // create an object of SingleObject\n    private static SingleObject _instance = new SingleObject();\n\n    // make the constructor private so that this class cannot be instantiated\n    private SingleObject() {}\n\n    // get the only object available\n    public static SingleObject GetInstance()\n    {\n        return _instance;\n    }\n\n    public string ShowMessage()\n    {\n        return \"Hello World!\";\n    }\n}\n\npublic static void main(String[] args)\n{\n    // illegal construct\n    // var object = new SingleObject();\n\n    // Get the only object available\n    var singletonObject = SingleObject.GetInstance();\n\n    // show the message\n    singletonObject.ShowMessage();\n}\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n## Variables\n\n<details>\n  <summary><b>Avoid nesting too deeply and return early</b></summary>\n\nToo many if else statements can make the code hard to follow. **Explicit is better than implicit**.\n\n**Bad:**\n\n```csharp\npublic bool IsShopOpen(string day)\n{\n    if (!string.IsNullOrEmpty(day))\n    {\n        day = day.ToLower();\n        if (day == \"friday\")\n        {\n            return true;\n        }\n        else if (day == \"saturday\")\n        {\n            return true;\n        }\n        else if (day == \"sunday\")\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    else\n    {\n        return false;\n    }\n\n}\n```\n\n**Good:**\n\n```csharp\npublic bool IsShopOpen(string day)\n{\n    if (string.IsNullOrEmpty(day))\n    {\n        return false;\n    }\n\n    var openingDays = new[] { \"friday\", \"saturday\", \"sunday\" };\n    return openingDays.Any(d => d == day.ToLower());\n}\n```\n\n**Bad:**\n\n```csharp\npublic long Fibonacci(int n)\n{\n    if (n < 50)\n    {\n        if (n != 0)\n        {\n            if (n != 1)\n            {\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        throw new System.Exception(\"Not supported\");\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic long Fibonacci(int n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    if (n == 1)\n    {\n        return 1;\n    }\n\n    if (n > 50)\n    {\n        throw new System.Exception(\"Not supported\");\n    }\n\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid mental mapping</b></summary>\n\nDon\u2019t force the reader of your code to translate what the variable means. **Explicit is better than implicit**.\n\n**Bad:**\n\n```csharp\nvar l = new[] { \"Austin\", \"New York\", \"San Francisco\" };\n\nfor (var i = 0; i < l.Count(); i++)\n{\n    var li = l[i];\n    DoStuff();\n    DoSomeOtherStuff();\n\n    // ...\n    // ...\n    // ...\n    // Wait, what is `li` for again?\n    Dispatch(li);\n}\n```\n\n**Good:**\n\n```csharp\nvar locations = new[] { \"Austin\", \"New York\", \"San Francisco\" };\n\nforeach (var location in locations)\n{\n    DoStuff();\n    DoSomeOtherStuff();\n\n    // ...\n    // ...\n    // ...\n    Dispatch(location);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid magic string</b></summary>\n\nMagic strings are string values that are specified directly within application code that have an impact on the application\u2019s behavior. Frequently, such strings will end up being duplicated within the system, and since they cannot automatically be updated using refactoring tools, they become a common source of bugs when changes are made to some strings but not others.\n\n**Bad**\n\n```csharp\nif (userRole == \"Admin\")\n{\n    // logic in here\n}\n```\n\n**Good**\n\n```csharp\nconst string ADMIN_ROLE = \"Admin\"\nif (userRole == ADMIN_ROLE)\n{\n    // logic in here\n}\n```\n\nUsing this we only have to change in centralize place and others will adapt it.\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't add unneeded context</b></summary>\n\nIf your class/object name tells you something, don't repeat that in your variable name.\n\n**Bad:**\n\n```csharp\npublic class Car\n{\n    public string CarMake { get; set; }\n    public string CarModel { get; set; }\n    public string CarColor { get; set; }\n\n    //...\n}\n```\n\n**Good:**\n\n```csharp\npublic class Car\n{\n    public string Make { get; set; }\n    public string Model { get; set; }\n    public string Color { get; set; }\n\n    //...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use meaningful and pronounceable variable names</b></summary>\n\n**Bad:**\n\n```csharp\nvar ymdstr = DateTime.UtcNow.ToString(\"MMMM dd, yyyy\");\n```\n\n**Good:**\n\n```csharp\nvar currentDate = DateTime.UtcNow.ToString(\"MMMM dd, yyyy\");\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use the same vocabulary for the same type of variable</b></summary>\n\n**Bad:**\n\n```csharp\nGetUserInfo();\nGetUserData();\nGetUserRecord();\nGetUserProfile();\n```\n\n**Good:**\n\n```csharp\nGetUser();\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use searchable names (part 1)</b></summary>\n\nWe will read more code than we will ever write. It's important that the code we do write is readable and searchable. By _not_ naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable.\n\n**Bad:**\n\n```csharp\n// What the heck is data for?\nvar data = new { Name = \"John\", Age = 42 };\n\nvar stream1 = new MemoryStream();\nvar ser1 = new DataContractJsonSerializer(typeof(object));\nser1.WriteObject(stream1, data);\n\nstream1.Position = 0;\nvar sr1 = new StreamReader(stream1);\nConsole.Write(\"JSON form of Data object: \");\nConsole.WriteLine(sr1.ReadToEnd());\n```\n\n**Good:**\n\n```csharp\nvar person = new Person\n{\n    Name = \"John\",\n    Age = 42\n};\n\nvar stream2 = new MemoryStream();\nvar ser2 = new DataContractJsonSerializer(typeof(Person));\nser2.WriteObject(stream2, data);\n\nstream2.Position = 0;\nvar sr2 = new StreamReader(stream2);\nConsole.Write(\"JSON form of Data object: \");\nConsole.WriteLine(sr2.ReadToEnd());\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use searchable names (part 2)</b></summary>\n\n**Bad:**\n\n```csharp\nvar data = new { Name = \"John\", Age = 42, PersonAccess = 4};\n\n// What the heck is 4 for?\nif (data.PersonAccess == 4)\n{\n    // do edit ...\n}\n```\n\n**Good:**\n\n```csharp\npublic enum PersonAccess : int\n{\n    ACCESS_READ = 1,\n    ACCESS_CREATE = 2,\n    ACCESS_UPDATE = 4,\n    ACCESS_DELETE = 8\n}\n\nvar person = new Person\n{\n    Name = \"John\",\n    Age = 42,\n    PersonAccess= PersonAccess.ACCESS_CREATE\n};\n\nif (person.PersonAccess == PersonAccess.ACCESS_UPDATE)\n{\n    // do edit ...\n}\n```\n\n**[\u2b06 Back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use explanatory variables</b></summary>\n\n**Bad:**\n\n```csharp\nconst string Address = \"One Infinite Loop, Cupertino 95014\";\nvar cityZipCodeRegex = @\"/^[^,\\]+[,\\\\s]+(.+?)\\s*(\\d{5})?$/\";\nvar matches = Regex.Matches(Address, cityZipCodeRegex);\nif (matches[0].Success == true && matches[1].Success == true)\n{\n    SaveCityZipCode(matches[0].Value, matches[1].Value);\n}\n```\n\n**Good:**\n\nDecrease dependence on regex by naming subpatterns.\n\n```csharp\nconst string Address = \"One Infinite Loop, Cupertino 95014\";\nvar cityZipCodeWithGroupRegex = @\"/^[^,\\]+[,\\\\s]+(?<city>.+?)\\s*(?<zipCode>\\d{5})?$/\";\nvar matchesWithGroup = Regex.Match(Address, cityZipCodeWithGroupRegex);\nvar cityGroup = matchesWithGroup.Groups[\"city\"];\nvar zipCodeGroup = matchesWithGroup.Groups[\"zipCode\"];\nif(cityGroup.Success == true && zipCodeGroup.Success == true)\n{\n    SaveCityZipCode(cityGroup.Value, zipCodeGroup.Value);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use default arguments instead of short circuiting or conditionals</b></summary>\n\n**Not good:**\n\nThis is not good because `breweryName` can be `NULL`.\n\nThis opinion is more understandable than the previous version, but it better controls the value of the variable.\n\n```csharp\npublic void CreateMicrobrewery(string name = null)\n{\n    var breweryName = !string.IsNullOrEmpty(name) ? name : \"Hipster Brew Co.\";\n    // ...\n}\n```\n\n**Good:**\n\n```csharp\npublic void CreateMicrobrewery(string breweryName = \"Hipster Brew Co.\")\n{\n    // ...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Functions\n\n<details>\n  <summary><b>Avoid side effects</b></summary>\n\nA function produces a side effect if it does anything other than take a value in and return another value or values. A side effect could be writing to a file, modifying some global variable, or accidentally wiring all your money to a stranger.\n\nNow, you do need to have side effects in a program on occasion. Like the previous example, you might need to write to a file. What you want to do is to centralize where you are doing this. Don't have several functions and classes that write to a particular file. Have one service that does it. One and only one.\n\nThe main point is to avoid common pitfalls like sharing state between objects without any structure, using mutable data types that can be written to by anything, and not centralizing where your side effects occur. If you can do this, you will be happier\nthan the vast majority of other programmers.\n\n**Bad:**\n\n```csharp\n// Global variable referenced by following function.\n// If we had another function that used this name, now it'd be an array and it could break it.\nvar name = \"Ryan McDermott\";\n\npublic void SplitAndEnrichFullName()\n{\n    var temp = name.Split(\" \");\n    name = $\"His first name is {temp[0]}, and his last name is {temp[1]}\"; // side effect\n}\n\nSplitAndEnrichFullName();\n\nConsole.WriteLine(name); // His first name is Ryan, and his last name is McDermott\n```\n\n**Good:**\n\n```csharp\npublic string SplitAndEnrichFullName(string name)\n{\n    var temp = name.Split(\" \");\n    return $\"His first name is {temp[0]}, and his last name is {temp[1]}\";\n}\n\nvar name = \"Ryan McDermott\";\nvar fullName = SplitAndEnrichFullName(name);\n\nConsole.WriteLine(name); // Ryan McDermott\nConsole.WriteLine(fullName); // His first name is Ryan, and his last name is McDermott\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid negative conditionals</b></summary>\n\n**Bad:**\n\n```csharp\npublic bool IsDOMNodeNotPresent(string node)\n{\n    // ...\n}\n\nif (!IsDOMNodeNotPresent(node))\n{\n    // ...\n}\n```\n\n**Good:**\n\n```csharp\npublic bool IsDOMNodePresent(string node)\n{\n    // ...\n}\n\nif (IsDOMNodePresent(node))\n{\n    // ...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid conditionals</b></summary>\n\nThis seems like an impossible task. Upon first hearing this, most people say, \"how am I supposed to do anything without an `if` statement?\" The answer is that you can use polymorphism to achieve the same task in many cases. The second question is usually, \"well that's great but why would I want to do that?\" The answer is a previous clean code concept we learned: a function should only do\none thing. When you have classes and functions that have `if` statements, you are telling your user that your function does more than one thing. Remember, just do one thing.\n\n**Bad:**\n\n```csharp\nclass Airplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        switch (_type)\n        {\n            case '777':\n                return GetMaxAltitude() - GetPassengerCount();\n            case 'Air Force One':\n                return GetMaxAltitude();\n            case 'Cessna':\n                return GetMaxAltitude() - GetFuelExpenditure();\n        }\n    }\n}\n```\n\n**Good:**\n\n```csharp\ninterface IAirplane\n{\n    // ...\n\n    double GetCruisingAltitude();\n}\n\nclass Boeing777 : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude() - GetPassengerCount();\n    }\n}\n\nclass AirForceOne : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude();\n    }\n}\n\nclass Cessna : IAirplane\n{\n    // ...\n\n    public double GetCruisingAltitude()\n    {\n        return GetMaxAltitude() - GetFuelExpenditure();\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid type-checking (part 1)</b></summary>\n\n**Bad:**\n\n```csharp\npublic Path TravelToTexas(object vehicle)\n{\n    if (vehicle.GetType() == typeof(Bicycle))\n    {\n        (vehicle as Bicycle).PeddleTo(new Location(\"texas\"));\n    }\n    else if (vehicle.GetType() == typeof(Car))\n    {\n        (vehicle as Car).DriveTo(new Location(\"texas\"));\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic Path TravelToTexas(Traveler vehicle)\n{\n    vehicle.TravelTo(new Location(\"texas\"));\n}\n```\n\nor\n\n```csharp\n// pattern matching\npublic Path TravelToTexas(object vehicle)\n{\n    if (vehicle is Bicycle bicycle)\n    {\n        bicycle.PeddleTo(new Location(\"texas\"));\n    }\n    else if (vehicle is Car car)\n    {\n        car.DriveTo(new Location(\"texas\"));\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid type-checking (part 2)</b></summary>\n\n**Bad:**\n\n```csharp\npublic int Combine(dynamic val1, dynamic val2)\n{\n    int value;\n    if (!int.TryParse(val1, out value) || !int.TryParse(val2, out value))\n    {\n        throw new Exception('Must be of type Number');\n    }\n\n    return val1 + val2;\n}\n```\n\n**Good:**\n\n```csharp\npublic int Combine(int val1, int val2)\n{\n    return val1 + val2;\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Avoid flags in method parameters</b></summary>\n\nA flag indicates that the method has more than one responsibility. It is best if the method only has a single responsibility. Split the method into two if a boolean parameter adds multiple responsibilities to the method.\n\n**Bad:**\n\n```csharp\npublic void CreateFile(string name, bool temp = false)\n{\n    if (temp)\n    {\n        Touch(\"./temp/\" + name);\n    }\n    else\n    {\n        Touch(name);\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic void CreateFile(string name)\n{\n    Touch(name);\n}\n\npublic void CreateTempFile(string name)\n{\n    Touch(\"./temp/\"  + name);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't write to global functions</b></summary>\n\nPolluting globals is a bad practice in many languages because you could clash with another library and the user of your API would be none-the-wiser until they get an exception in production. Let's think about an example: what if you wanted to have configuration array.\nYou could write global function like `Config()`, but it could clash with another library that tried to do the same thing.\n\n**Bad:**\n\n```csharp\npublic Dictionary<string, string> Config()\n{\n    return new Dictionary<string,string>(){\n        [\"foo\"] = \"bar\"\n    };\n}\n```\n\n**Good:**\n\n```csharp\nclass Configuration\n{\n    private Dictionary<string, string> _configuration;\n\n    public Configuration(Dictionary<string, string> configuration)\n    {\n        _configuration = configuration;\n    }\n\n    public string[] Get(string key)\n    {\n        return _configuration.ContainsKey(key) ? _configuration[key] : null;\n    }\n}\n```\n\nLoad configuration and create instance of `Configuration` class\n\n```csharp\nvar configuration = new Configuration(new Dictionary<string, string>() {\n    [\"foo\"] = \"bar\"\n});\n```\n\nAnd now you must use instance of `Configuration` in your application.\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't use a Singleton pattern</b></summary>\n\nSingleton is an [anti-pattern](https://en.wikipedia.org/wiki/Singleton_pattern). Paraphrased from Brian Button:\n\n1. They are generally used as a **global instance**, why is that so bad? Because **you hide the dependencies** of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a [code smell](https://en.wikipedia.org/wiki/Code_smell).\n2. They violate the [single responsibility principle](#single-responsibility-principle-srp): by virtue of the fact that **they control their own creation and lifecycle**.\n3. They inherently cause code to be tightly [coupled](https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29). This makes faking them out under **test rather difficult** in many cases.\n4. They carry state around for the lifetime of the application. Another hit to testing since **you can end up with a situation where tests need to be ordered** which is a big no for unit tests. Why? Because each unit test should be independent from the other.\n\nThere is also very good thoughts by [Misko Hevery](http://misko.hevery.com/about/) about the [root of problem](http://misko.hevery.com/2008/08/25/root-cause-of-singletons/).\n\n**Bad:**\n\n```csharp\nclass DBConnection\n{\n    private static DBConnection _instance;\n\n    private DBConnection()\n    {\n        // ...\n    }\n\n    public static GetInstance()\n    {\n        if (_instance == null)\n        {\n            _instance = new DBConnection();\n        }\n\n        return _instance;\n    }\n\n    // ...\n}\n\nvar singleton = DBConnection.GetInstance();\n```\n\n**Good:**\n\n```csharp\nclass DBConnection\n{\n    public DBConnection(IOptions<DbConnectionOption> options)\n    {\n        // ...\n    }\n\n    // ...\n}\n```\n\nCreate instance of `DBConnection` class and configure it with [Option pattern](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1).\n\n```csharp\nvar options = <resolve from IOC>;\nvar connection = new DBConnection(options);\n```\n\nAnd now you must use instance of `DBConnection` in your application.\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Function arguments (2 or fewer ideally)</b></summary>\n\nLimiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument.\n\nZero arguments is the ideal case. One or two arguments is ok, and three should be avoided. Anything more than that should be consolidated. Usually, if you have more than two arguments then your function is trying to do too much. In cases where it's not, most of the time a higher-level object will suffice as an argument.\n\n**Bad:**\n\n```csharp\npublic void CreateMenu(string title, string body, string buttonText, bool cancellable)\n{\n    // ...\n}\n```\n\n**Good:**\n\n```csharp\npublic class MenuConfig\n{\n    public string Title { get; set; }\n    public string Body { get; set; }\n    public string ButtonText { get; set; }\n    public bool Cancellable { get; set; }\n}\n\nvar config = new MenuConfig\n{\n    Title = \"Foo\",\n    Body = \"Bar\",\n    ButtonText = \"Baz\",\n    Cancellable = true\n};\n\npublic void CreateMenu(MenuConfig config)\n{\n    // ...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Functions should do one thing</b></summary>\n\nThis is by far the most important rule in software engineering. When functions do more than one thing, they are harder to compose, test, and reason about. When you can isolate a function to just one action, they can be refactored easily and your code will read much\ncleaner. If you take nothing else away from this guide other than this, you'll be ahead of many developers.\n\n**Bad:**\n\n```csharp\npublic void SendEmailToListOfClients(string[] clients)\n{\n    foreach (var client in clients)\n    {\n        var clientRecord = db.Find(client);\n        if (clientRecord.IsActive())\n        {\n            Email(client);\n        }\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic void SendEmailToListOfClients(string[] clients)\n{\n    var activeClients = GetActiveClients(clients);\n    // Do some logic\n}\n\npublic List<Client> GetActiveClients(string[] clients)\n{\n    return db.Find(clients).Where(s => s.Status == \"Active\");\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Function names should say what they do</b></summary>\n\n**Bad:**\n\n```csharp\npublic class Email\n{\n    //...\n\n    public void Handle()\n    {\n        SendMail(this._to, this._subject, this._body);\n    }\n}\n\nvar message = new Email(...);\n// What is this? A handle for the message? Are we writing to a file now?\nmessage.Handle();\n```\n\n**Good:**\n\n```csharp\npublic class Email\n{\n    //...\n\n    public void Send()\n    {\n        SendMail(this._to, this._subject, this._body);\n    }\n}\n\nvar message = new Email(...);\n// Clear and obvious\nmessage.Send();\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Functions should only be one level of abstraction</b></summary>\n\n> Not finished yet\n\nWhen you have more than one level of abstraction your function is usually doing too much. Splitting up functions leads to reusability and easier testing.\n\n**Bad:**\n\n```csharp\npublic string ParseBetterJSAlternative(string code)\n{\n    var regexes = [\n        // ...\n    ];\n\n    var statements = explode(\" \", code);\n    var tokens = new string[] {};\n    foreach (var regex in regexes)\n    {\n        foreach (var statement in statements)\n        {\n            // ...\n        }\n    }\n\n    var ast = new string[] {};\n    foreach (var token in tokens)\n    {\n        // lex...\n    }\n\n    foreach (var node in ast)\n    {\n        // parse...\n    }\n}\n```\n\n**Bad too:**\n\nWe have carried out some of the functionality, but the `ParseBetterJSAlternative()` function is still very complex and not testable.\n\n```csharp\npublic string Tokenize(string code)\n{\n    var regexes = new string[]\n    {\n        // ...\n    };\n\n    var statements = explode(\" \", code);\n    var tokens = new string[] {};\n    foreach (var regex in regexes)\n    {\n        foreach (var statement in statements)\n        {\n            tokens[] = /* ... */;\n        }\n    }\n\n    return tokens;\n}\n\npublic string Lexer(string[] tokens)\n{\n    var ast = new string[] {};\n    foreach (var token in tokens)\n    {\n        ast[] = /* ... */;\n    }\n\n    return ast;\n}\n\npublic string ParseBetterJSAlternative(string code)\n{\n    var tokens = Tokenize(code);\n    var ast = Lexer(tokens);\n    foreach (var node in ast)\n    {\n        // parse...\n    }\n}\n```\n\n**Good:**\n\nThe best solution is move out the dependencies of `ParseBetterJSAlternative()` function.\n\n```csharp\nclass Tokenizer\n{\n    public string Tokenize(string code)\n    {\n        var regexes = new string[] {\n            // ...\n        };\n\n        var statements = explode(\" \", code);\n        var tokens = new string[] {};\n        foreach (var regex in regexes)\n        {\n            foreach (var statement in statements)\n            {\n                tokens[] = /* ... */;\n            }\n        }\n\n        return tokens;\n    }\n}\n\nclass Lexer\n{\n    public string Lexify(string[] tokens)\n    {\n        var ast = new[] {};\n        foreach (var token in tokens)\n        {\n            ast[] = /* ... */;\n        }\n\n        return ast;\n    }\n}\n\nclass BetterJSAlternative\n{\n    private string _tokenizer;\n    private string _lexer;\n\n    public BetterJSAlternative(Tokenizer tokenizer, Lexer lexer)\n    {\n        _tokenizer = tokenizer;\n        _lexer = lexer;\n    }\n\n    public string Parse(string code)\n    {\n        var tokens = _tokenizer.Tokenize(code);\n        var ast = _lexer.Lexify(tokens);\n        foreach (var node in ast)\n        {\n            // parse...\n        }\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Function callers and callees should be close</b></summary>\n\nIf a function calls another, keep those functions vertically close in the source file. Ideally, keep the caller right above the callee. We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way.\n\n**Bad:**\n\n```csharp\nclass PerformanceReview\n{\n    private readonly Employee _employee;\n\n    public PerformanceReview(Employee employee)\n    {\n        _employee = employee;\n    }\n\n    private IEnumerable<PeersData> LookupPeers()\n    {\n        return db.lookup(_employee, 'peers');\n    }\n\n    private ManagerData LookupManager()\n    {\n        return db.lookup(_employee, 'manager');\n    }\n\n    private IEnumerable<PeerReviews> GetPeerReviews()\n    {\n        var peers = LookupPeers();\n        // ...\n    }\n\n    public PerfReviewData PerfReview()\n    {\n        GetPeerReviews();\n        GetManagerReview();\n        GetSelfReview();\n    }\n\n    public ManagerData GetManagerReview()\n    {\n        var manager = LookupManager();\n    }\n\n    public EmployeeData GetSelfReview()\n    {\n        // ...\n    }\n}\n\nvar  review = new PerformanceReview(employee);\nreview.PerfReview();\n```\n\n**Good:**\n\n```csharp\nclass PerformanceReview\n{\n    private readonly Employee _employee;\n\n    public PerformanceReview(Employee employee)\n    {\n        _employee = employee;\n    }\n\n    public PerfReviewData PerfReview()\n    {\n        GetPeerReviews();\n        GetManagerReview();\n        GetSelfReview();\n    }\n\n    private IEnumerable<PeerReviews> GetPeerReviews()\n    {\n        var peers = LookupPeers();\n        // ...\n    }\n\n    private IEnumerable<PeersData> LookupPeers()\n    {\n        return db.lookup(_employee, 'peers');\n    }\n\n    private ManagerData GetManagerReview()\n    {\n        var manager = LookupManager();\n        return manager;\n    }\n\n    private ManagerData LookupManager()\n    {\n        return db.lookup(_employee, 'manager');\n    }\n\n    private EmployeeData GetSelfReview()\n    {\n        // ...\n    }\n}\n\nvar review = new PerformanceReview(employee);\nreview.PerfReview();\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Encapsulate conditionals</b></summary>\n\n**Bad:**\n\n```csharp\nif (article.state == \"published\")\n{\n    // ...\n}\n```\n\n**Good:**\n\n```csharp\nif (article.IsPublished())\n{\n    // ...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Remove dead code</b></summary>\n\nDead code is just as bad as duplicate code. There's no reason to keep it in your codebase. If it's not being called, get rid of it! It will still be safe in your version history if you still need it.\n\n**Bad:**\n\n```csharp\npublic void OldRequestModule(string url)\n{\n    // ...\n}\n\npublic void NewRequestModule(string url)\n{\n    // ...\n}\n\nvar request = NewRequestModule(requestUrl);\nInventoryTracker(\"apples\", request, \"www.inventory-awesome.io\");\n```\n\n**Good:**\n\n```csharp\npublic void RequestModule(string url)\n{\n    // ...\n}\n\nvar request = RequestModule(requestUrl);\nInventoryTracker(\"apples\", request, \"www.inventory-awesome.io\");\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Objects and Data Structures\n\n<details>\n  <summary><b>Use getters and setters</b></summary>\n\nIn C# / VB.NET you can set `public`, `protected` and `private` keywords for methods.\nUsing it, you can control properties modification on an object.\n\n- When you want to do more beyond getting an object property, you don't have to look up and change every accessor in your codebase.\n- Makes adding validation simple when doing a `set`.\n- Encapsulates the internal representation.\n- Easy to add logging and error handling when getting and setting.\n- Inheriting this class, you can override default functionality.\n- You can lazy load your object's properties, let's say getting it from a server.\n\nAdditionally, this is part of Open/Closed principle, from object-oriented design principles.\n\n**Bad:**\n\n```csharp\nclass BankAccount\n{\n    public double Balance = 1000;\n}\n\nvar bankAccount = new BankAccount();\n\n// Fake buy shoes...\nbankAccount.Balance -= 100;\n```\n\n**Good:**\n\n```csharp\nclass BankAccount\n{\n    private double _balance = 0.0D;\n\n    pubic double Balance {\n        get {\n            return _balance;\n        }\n    }\n\n    public BankAccount(balance = 1000)\n    {\n       _balance = balance;\n    }\n\n    public void WithdrawBalance(int amount)\n    {\n        if (amount > _balance)\n        {\n            throw new Exception('Amount greater than available balance.');\n        }\n\n        _balance -= amount;\n    }\n\n    public void DepositBalance(int amount)\n    {\n        _balance += amount;\n    }\n}\n\nvar bankAccount = new BankAccount();\n\n// Buy shoes...\nbankAccount.WithdrawBalance(price);\n\n// Get balance\nbalance = bankAccount.Balance;\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Make objects have private/protected members</b></summary>\n\n**Bad:**\n\n```csharp\nclass Employee\n{\n    public string Name { get; set; }\n\n    public Employee(string name)\n    {\n        Name = name;\n    }\n}\n\nvar employee = new Employee(\"John Doe\");\nConsole.WriteLine(employee.Name); // Employee name: John Doe\n```\n\n**Good:**\n\n```csharp\nclass Employee\n{\n    public string Name { get; }\n\n    public Employee(string name)\n    {\n        Name = name;\n    }\n}\n\nvar employee = new Employee(\"John Doe\");\nConsole.WriteLine(employee.Name); // Employee name: John Doe\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Classes\n\n<details>\n  <summary><b>Use method chaining</b></summary>\n\nThis pattern is very useful and commonly used in many libraries. It allows your code to be expressive, and less verbose.\nFor that reason, use method chaining and take a look at how clean your code will be.\n\n**Good:**\n\n```csharp\npublic static class ListExtensions\n{\n    public static List<T> FluentAdd<T>(this List<T> list, T item)\n    {\n        list.Add(item);\n        return list;\n    }\n\n    public static List<T> FluentClear<T>(this List<T> list)\n    {\n        list.Clear();\n        return list;\n    }\n\n    public static List<T> FluentForEach<T>(this List<T> list, Action<T> action)\n    {\n        list.ForEach(action);\n        return list;\n    }\n\n    public static List<T> FluentInsert<T>(this List<T> list, int index, T item)\n    {\n        list.Insert(index, item);\n        return list;\n    }\n\n    public static List<T> FluentRemoveAt<T>(this List<T> list, int index)\n    {\n        list.RemoveAt(index);\n        return list;\n    }\n\n    public static List<T> FluentReverse<T>(this List<T> list)\n    {\n        list.Reverse();\n        return list;\n    }\n}\n\ninternal static void ListFluentExtensions()\n{\n    var list = new List<int>() { 1, 2, 3, 4, 5 }\n        .FluentAdd(1)\n        .FluentInsert(0, 0)\n        .FluentRemoveAt(1)\n        .FluentReverse()\n        .FluentForEach(value => value.WriteLine())\n        .FluentClear();\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Prefer composition over inheritance</b></summary>\n\nAs stated famously in [_Design Patterns_](https://en.wikipedia.org/wiki/Design_Patterns) by the Gang of Four,\nyou should prefer composition over inheritance where you can. There are lots of good reasons to use inheritance and lots of good reasons to use composition.\n\nThe main point for this maxim is that if your mind instinctively goes for inheritance, try to think if composition could model your problem better. In some cases it can.\n\nYou might be wondering then, \"when should I use inheritance?\" It\ndepends on your problem at hand, but this is a decent list of when inheritance makes more sense than composition:\n\n1. Your inheritance represents an \"is-a\" relationship and not a \"has-a\" relationship (Human->Animal vs. User->UserDetails).\n2. You can reuse code from the base classes (Humans can move like all animals).\n3. You want to make global changes to derived classes by changing a base class (Change the caloric expenditure of all animals when they move).\n\n**Bad:**\n\n```csharp\nclass Employee\n{\n    private string Name { get; set; }\n    private string Email { get; set; }\n\n    public Employee(string name, string email)\n    {\n        Name = name;\n        Email = email;\n    }\n\n    // ...\n}\n\n// Bad because Employees \"have\" tax data.\n// EmployeeTaxData is not a type of Employee\n\nclass EmployeeTaxData : Employee\n{\n    private string Name { get; }\n    private string Email { get; }\n\n    public EmployeeTaxData(string name, string email, string ssn, string salary)\n    {\n         // ...\n    }\n\n    // ...\n}\n```\n\n**Good:**\n\n```csharp\nclass EmployeeTaxData\n{\n    public string Ssn { get; }\n    public string Salary { get; }\n\n    public EmployeeTaxData(string ssn, string salary)\n    {\n        Ssn = ssn;\n        Salary = salary;\n    }\n\n    // ...\n}\n\nclass Employee\n{\n    public string Name { get; }\n    public string Email { get; }\n    public EmployeeTaxData TaxData { get; }\n\n    public Employee(string name, string email)\n    {\n        Name = name;\n        Email = email;\n    }\n\n    public void SetTax(string ssn, double salary)\n    {\n        TaxData = new EmployeeTaxData(ssn, salary);\n    }\n\n    // ...\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## SOLID\n\n<details>\n  <summary><b>What is SOLID?</b></summary>\n\n**SOLID** is the mnemonic acronym introduced by Michael Feathers for the first five principles named by Robert Martin, which meant five basic principles of object-oriented programming and design.\n\n- [S: Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)\n- [O: Open/Closed Principle (OCP)](#openclosed-principle-ocp)\n- [L: Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)\n- [I: Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)\n- [D: Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)\n\n</details>\n\n<details>\n  <summary><b>Single Responsibility Principle (SRP)</b></summary>\n\nAs stated in Clean Code, \"There should never be more than one reason for a class to change\". It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important.\n\nIt's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase.\n\n**Bad:**\n\n```csharp\nclass UserSettings\n{\n    private User User;\n\n    public UserSettings(User user)\n    {\n        User = user;\n    }\n\n    public void ChangeSettings(Settings settings)\n    {\n        if (verifyCredentials())\n        {\n            // ...\n        }\n    }\n\n    private bool VerifyCredentials()\n    {\n        // ...\n    }\n}\n```\n\n**Good:**\n\n```csharp\nclass UserAuth\n{\n    private User User;\n\n    public UserAuth(User user)\n    {\n        User = user;\n    }\n\n    public bool VerifyCredentials()\n    {\n        // ...\n    }\n}\n\nclass UserSettings\n{\n    private User User;\n    private UserAuth Auth;\n\n    public UserSettings(User user)\n    {\n        User = user;\n        Auth = new UserAuth(user);\n    }\n\n    public void ChangeSettings(Settings settings)\n    {\n        if (Auth.VerifyCredentials())\n        {\n            // ...\n        }\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Open/Closed Principle (OCP)</b></summary>\n\nAs stated by Bertrand Meyer, \"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\" What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.\n\n**Bad:**\n\n```csharp\nabstract class AdapterBase\n{\n    protected string Name;\n\n    public string GetName()\n    {\n        return Name;\n    }\n}\n\nclass AjaxAdapter : AdapterBase\n{\n    public AjaxAdapter()\n    {\n        Name = \"ajaxAdapter\";\n    }\n}\n\nclass NodeAdapter : AdapterBase\n{\n    public NodeAdapter()\n    {\n        Name = \"nodeAdapter\";\n    }\n}\n\nclass HttpRequester : AdapterBase\n{\n    private readonly AdapterBase Adapter;\n\n    public HttpRequester(AdapterBase adapter)\n    {\n        Adapter = adapter;\n    }\n\n    public bool Fetch(string url)\n    {\n        var adapterName = Adapter.GetName();\n\n        if (adapterName == \"ajaxAdapter\")\n        {\n            return MakeAjaxCall(url);\n        }\n        else if (adapterName == \"httpNodeAdapter\")\n        {\n            return MakeHttpCall(url);\n        }\n    }\n\n    private bool MakeAjaxCall(string url)\n    {\n        // request and return promise\n    }\n\n    private bool MakeHttpCall(string url)\n    {\n        // request and return promise\n    }\n}\n```\n\n**Good:**\n\n```csharp\ninterface IAdapter\n{\n    bool Request(string url);\n}\n\nclass AjaxAdapter : IAdapter\n{\n    public bool Request(string url)\n    {\n        // request and return promise\n    }\n}\n\nclass NodeAdapter : IAdapter\n{\n    public bool Request(string url)\n    {\n        // request and return promise\n    }\n}\n\nclass HttpRequester\n{\n    private readonly IAdapter Adapter;\n\n    public HttpRequester(IAdapter adapter)\n    {\n        Adapter = adapter;\n    }\n\n    public bool Fetch(string url)\n    {\n        return Adapter.Request(url);\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Liskov Substitution Principle (LSP)</b></summary>\n\nThis is a scary term for a very simple concept. It's formally defined as \"If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed,\netc.).\" That's an even scarier definition.\n\nThe best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the \"is-a\" relationship via inheritance, you quickly\nget into trouble.\n\n**Bad:**\n\n```csharp\nclass Rectangle\n{\n    protected double Width = 0;\n    protected double Height = 0;\n\n    public Drawable Render(double area)\n    {\n        // ...\n    }\n\n    public void SetWidth(double width)\n    {\n        Width = width;\n    }\n\n    public void SetHeight(double height)\n    {\n        Height = height;\n    }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Square : Rectangle\n{\n    public double SetWidth(double width)\n    {\n        Width = Height = width;\n    }\n\n    public double SetHeight(double height)\n    {\n        Width = Height = height;\n    }\n}\n\nDrawable RenderLargeRectangles(Rectangle rectangles)\n{\n    foreach (rectangle in rectangles)\n    {\n        rectangle.SetWidth(4);\n        rectangle.SetHeight(5);\n        var area = rectangle.GetArea(); // BAD: Will return 25 for Square. Should be 20.\n        rectangle.Render(area);\n    }\n}\n\nvar rectangles = new[] { new Rectangle(), new Rectangle(), new Square() };\nRenderLargeRectangles(rectangles);\n```\n\n**Good:**\n\n```csharp\nabstract class ShapeBase\n{\n    protected double Width = 0;\n    protected double Height = 0;\n\n    abstract public double GetArea();\n\n    public Drawable Render(double area)\n    {\n        // ...\n    }\n}\n\nclass Rectangle : ShapeBase\n{\n    public void SetWidth(double width)\n    {\n        Width = width;\n    }\n\n    public void SetHeight(double height)\n    {\n        Height = height;\n    }\n\n    public double GetArea()\n    {\n        return Width * Height;\n    }\n}\n\nclass Square : ShapeBase\n{\n    private double Length = 0;\n\n    public double SetLength(double length)\n    {\n        Length = length;\n    }\n\n    public double GetArea()\n    {\n        return Math.Pow(Length, 2);\n    }\n}\n\nDrawable RenderLargeRectangles(Rectangle rectangles)\n{\n    foreach (rectangle in rectangles)\n    {\n        if (rectangle is Square)\n        {\n            rectangle.SetLength(5);\n        }\n        else if (rectangle is Rectangle)\n        {\n            rectangle.SetWidth(4);\n            rectangle.SetHeight(5);\n        }\n\n        var area = rectangle.GetArea();\n        rectangle.Render(area);\n    }\n}\n\nvar shapes = new[] { new Rectangle(), new Rectangle(), new Square() };\nRenderLargeRectangles(shapes);\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Interface Segregation Principle (ISP)</b></summary>\n\nISP states that \"Clients should not be forced to depend upon interfaces that they do not use.\"\n\nA good example to look at that demonstrates this principle is for\nclasses that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a \"fat interface\".\n\n**Bad:**\n\n```csharp\npublic interface IEmployee\n{\n    void Work();\n    void Eat();\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n\n    public void Eat()\n    {\n        // ...... eating in lunch break\n    }\n}\n\npublic class Robot : IEmployee\n{\n    public void Work()\n    {\n        //.... working much more\n    }\n\n    public void Eat()\n    {\n        //.... robot can't eat, but it must implement this method\n    }\n}\n```\n\n**Good:**\n\nNot every worker is an employee, but every employee is an worker.\n\n```csharp\npublic interface IWorkable\n{\n    void Work();\n}\n\npublic interface IFeedable\n{\n    void Eat();\n}\n\npublic interface IEmployee : IFeedable, IWorkable\n{\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n\n    public void Eat()\n    {\n        //.... eating in lunch break\n    }\n}\n\n// robot can only work\npublic class Robot : IWorkable\n{\n    public void Work()\n    {\n        // ....working\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Dependency Inversion Principle (DIP)</b></summary>\n\nThis principle states two essential things:\n\n1. High-level modules should not depend on low-level modules. Both should depend on abstractions.\n2. Abstractions should not depend upon details. Details should depend on abstractions.\n\nThis can be hard to understand at first, but if you've worked with .NET/.NET Core framework, you've seen an implementation of this principle in the form of [Dependency Injection](https://martinfowler.com/articles/injection.html) (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up.\nIt can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor.\n\n**Bad:**\n\n```csharp\npublic abstract class EmployeeBase\n{\n    protected virtual void Work()\n    {\n        // ....working\n    }\n}\n\npublic class Human : EmployeeBase\n{\n    public override void Work()\n    {\n        //.... working much more\n    }\n}\n\npublic class Robot : EmployeeBase\n{\n    public override void Work()\n    {\n        //.... working much, much more\n    }\n}\n\npublic class Manager\n{\n    private readonly Robot _robot;\n    private readonly Human _human;\n\n    public Manager(Robot robot, Human human)\n    {\n        _robot = robot;\n        _human = human;\n    }\n\n    public void Manage()\n    {\n        _robot.Work();\n        _human.Work();\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic interface IEmployee\n{\n    void Work();\n}\n\npublic class Human : IEmployee\n{\n    public void Work()\n    {\n        // ....working\n    }\n}\n\npublic class Robot : IEmployee\n{\n    public void Work()\n    {\n        //.... working much more\n    }\n}\n\npublic class Manager\n{\n    private readonly IEnumerable<IEmployee> _employees;\n\n    public Manager(IEnumerable<IEmployee> employees)\n    {\n        _employees = employees;\n    }\n\n    public void Manage()\n    {\n        foreach (var employee in _employees)\n        {\n            _employee.Work();\n        }\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don\u2019t repeat yourself (DRY)</b></summary>\n\nTry to observe the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.\n\nDo your absolute best to avoid duplicate code. Duplicate code is bad because it means that there's more than one place to alter something if you need to change some logic.\n\nImagine if you run a restaurant and you keep track of your inventory: all your tomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep this on, then all have to be updated when you serve a dish with tomatoes in them. If you only have one list, there's only one place to update!\n\nOftentimes you have duplicate code because you have two or more slightly different things, that share a lot in common, but their differences force you to have two or more separate functions that do much of the same things. Removing duplicate code means creating an abstraction that can handle this set of different things with just one function/module/class.\n\nGetting the abstraction right is critical, that's why you should follow the SOLID principles laid out in the [Classes](#classes) section. Bad abstractions can be worse than duplicate code, so be careful! Having said this, if you can make a good abstraction, do it! Don't repeat yourself, otherwise you'll find yourself updating multiple places anytime you want to change one thing.\n\n**Bad:**\n\n```csharp\npublic List<EmployeeData> ShowDeveloperList(Developers developers)\n{\n    foreach (var developers in developer)\n    {\n        var expectedSalary = developer.CalculateExpectedSalary();\n        var experience = developer.GetExperience();\n        var githubLink = developer.GetGithubLink();\n        var data = new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        Render(data);\n    }\n}\n\npublic List<ManagerData> ShowManagerList(Manager managers)\n{\n    foreach (var manager in managers)\n    {\n        var expectedSalary = manager.CalculateExpectedSalary();\n        var experience = manager.GetExperience();\n        var githubLink = manager.GetGithubLink();\n        var data =\n        new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        render(data);\n    }\n}\n```\n\n**Good:**\n\n```csharp\npublic List<EmployeeData> ShowList(Employee employees)\n{\n    foreach (var employee in employees)\n    {\n        var expectedSalary = employees.CalculateExpectedSalary();\n        var experience = employees.GetExperience();\n        var githubLink = employees.GetGithubLink();\n        var data =\n        new[] {\n            expectedSalary,\n            experience,\n            githubLink\n        };\n\n        render(data);\n    }\n}\n```\n\n**Very good:**\n\nIt is better to use a compact version of the code.\n\n```csharp\npublic List<EmployeeData> ShowList(Employee employees)\n{\n    foreach (var employee in employees)\n    {\n        render(new[] {\n            employee.CalculateExpectedSalary(),\n            employee.GetExperience(),\n            employee.GetGithubLink()\n        });\n    }\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Testing\n\n<details>\n  <summary><b>Basic concept of testing</b></summary>\n\nTesting is more important than shipping. If you have no tests or an\ninadequate amount, then every time you ship code you won't be sure that you didn't break anything. Deciding on what constitutes an adequate amount is up to your team, but having 100% coverage (all statements and branches) is how you achieve very high confidence and developer peace of mind. This means that in addition to having a great testing framework, you also need to use a [good coverage tool](https://docs.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested).\n\nThere's no excuse to not write tests. There's [plenty of good .NET test frameworks](https://github.com/thangchung/awesome-dotnet-core#testing), so find one that your team prefers. When you find one that works for your team, then aim to always write tests for every new feature/module you introduce. If your preferred method is Test Driven Development (TDD), that is great, but the main point is to just make sure you are reaching your coverage goals before launching any feature, or refactoring an existing one.\n\n</details>\n\n<details>\n  <summary><b>Single concept per test</b></summary>\n\nEnsures that your tests are laser focused and not testing miscellaenous (non-related) things, forces [AAA patern](http://wiki.c2.com/?ArrangeActAssert) used to make your codes more clean and readable.\n\n**Bad:**\n\n```csharp\n\npublic class MakeDotNetGreatAgainTests\n{\n    [Fact]\n    public void HandleDateBoundaries()\n    {\n        var date = new MyDateTime(\"1/1/2015\");\n        date.AddDays(30);\n        Assert.Equal(\"1/31/2015\", date);\n\n        date = new MyDateTime(\"2/1/2016\");\n        date.AddDays(28);\n        Assert.Equal(\"02/29/2016\", date);\n\n        date = new MyDateTime(\"2/1/2015\");\n        date.AddDays(28);\n        Assert.Equal(\"03/01/2015\", date);\n    }\n}\n\n```\n\n**Good:**\n\n```csharp\n\npublic class MakeDotNetGreatAgainTests\n{\n    [Fact]\n    public void Handle30DayMonths()\n    {\n        // Arrange\n        var date = new MyDateTime(\"1/1/2015\");\n\n        // Act\n        date.AddDays(30);\n\n        // Assert\n        Assert.Equal(\"1/31/2015\", date);\n    }\n\n    [Fact]\n    public void HandleLeapYear()\n    {\n        // Arrange\n        var date = new MyDateTime(\"2/1/2016\");\n\n        // Act\n        date.AddDays(28);\n\n        // Assert\n        Assert.Equal(\"02/29/2016\", date);\n    }\n\n    [Fact]\n    public void HandleNonLeapYear()\n    {\n        // Arrange\n        var date = new MyDateTime(\"2/1/2015\");\n\n        // Act\n        date.AddDays(28);\n\n        // Assert\n        Assert.Equal(\"03/01/2015\", date);\n    }\n}\n\n```\n\n> Soure https://www.codingblocks.net/podcast/how-to-write-amazing-unit-tests\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Concurrency\n\n<details>\n  <summary><b>Use Async/Await</b></summary>\n\n**Summary of Asynchronous Programming Guidelines**\n\n| Name              | Description                                       | Exceptions                      |\n| ----------------- | ------------------------------------------------- | ------------------------------- |\n| Avoid async void  | Prefer async Task methods over async void methods | Event handlers                  |\n| Async all the way | Don't mix blocking and async code                 | Console main method (C# <= 7.0) |\n| Configure context | Use `ConfigureAwait(false)` when you can          | Methods that require con\u00adtext   |\n\n**The Async Way of Doing Things**\n\n| To Do This ...                           | Instead of This ...        | Use This             |\n| ---------------------------------------- | -------------------------- | -------------------- |\n| Retrieve the result of a background task | `Task.Wait or Task.Result` | `await`              |\n| Wait for any task to complete            | `Task.WaitAny`             | `await Task.WhenAny` |\n| Retrieve the results of multiple tasks   | `Task.WaitAll`             | `await Task.WhenAll` |\n| Wait a period of time                    | `Thread.Sleep`             | `await Task.Delay`   |\n\n**Best practice**\n\nThe async/await is the best for IO bound tasks (networking communication, database communication, http request, etc.) but it is not good to apply on computational bound tasks (traverse on the huge list, render a hugge image, etc.). Because it will release the holding thread to the thread pool and CPU/cores available will not involve to process those tasks. Therefore, we should avoid using Async/Await for computional bound tasks.\n\nFor dealing with computational bound tasks, prefer to use `Task.Factory.CreateNew` with `TaskCreationOptions` is `LongRunning`. It will start a new background thread to process a heavy computational bound task without release it back to the thread pool until the task being completed.\n\n**Know Your Tools**\n\nThere's a lot to learn about async and await, and it's natural to get a little disoriented. Here's a quick reference of solutions to common problems.\n\n**Solutions to Common Async Problems**\n\n| Problem                                         | Solution                                                                          |\n| ----------------------------------------------- | --------------------------------------------------------------------------------- |\n| Create a task to execute code                   | `Task.Run` or `TaskFactory.StartNew` (not the `Task` constructor or `Task.Start`) |\n| Create a task wrapper for an operation or event | `TaskFactory.FromAsync` or `TaskCompletionSource<T>`                              |\n| Support cancellation                            | `CancellationTokenSource` and `CancellationToken`                                 |\n| Report progress                                 | `IProgress<T>` and `Progress<T>`                                                  |\n| Handle streams of data                          | TPL Dataflow or Reactive Extensions                                               |\n| Synchronize access to a shared resource         | `SemaphoreSlim`                                                                   |\n| Asynchronously initialize a resource            | `AsyncLazy<T>`                                                                    |\n| Async-ready producer/consumer structures        | TPL Dataflow or `AsyncCollection<T>`                                              |\n\nRead the [Task-based Asynchronous Pattern (TAP) document](http://www.microsoft.com/download/en/details.aspx?id=19957).\nIt is extremely well-written, and includes guidance on API design and the proper use of async/await (including cancellation and progress reporting).\n\nThere are many new await-friendly techniques that should be used instead of the old blocking techniques. If you have any of these Old examples in your new async code, you're Doing It Wrong(TM):\n\n| Old                | New                                  | Description                                                   |\n| ------------------ | ------------------------------------ | ------------------------------------------------------------- |\n| `task.Wait`        | `await task`                         | Wait/await for a task to complete                             |\n| `task.Result`      | `await task`                         | Get the result of a completed task                            |\n| `Task.WaitAny`     | `await Task.WhenAny`                 | Wait/await for one of a collection of tasks to complete       |\n| `Task.WaitAll`     | `await Task.WhenAll`                 | Wait/await for every one of a collection of tasks to complete |\n| `Thread.Sleep`     | `await Task.Delay`                   | Wait/await for a period of time                               |\n| `Task` constructor | `Task.Run` or `TaskFactory.StartNew` | Create a code-based task                                      |\n\n> Source https://gist.github.com/jonlabelle/841146854b23b305b50fa5542f84b20c\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Error Handling\n\n<details>\n  <summary><b>Basic concept of error handling</b></summary>\n\nThrown errors are a good thing! They mean the runtime has successfully identified when something in your program has gone wrong and it's letting you know by stopping function execution on the current stack, killing the process (in .NET/.NET Core), and notifying you in the console with a stack trace.\n\n</details>\n\n<details>\n  <summary><b>Don't use 'throw ex' in catch block</b></summary>\n\nIf you need to re-throw an exception after catching it, use just 'throw'\nBy using this, you will save the stack trace. But in the bad option below,\nyou will lost the stack trace.\n\n**Bad:**\n\n```csharp\ntry\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n    // Any action something like roll-back or logging etc.\n    throw ex;\n}\n```\n\n**Good:**\n\n```csharp\ntry\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n    // Any action something like roll-back or logging etc.\n    throw;\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't ignore caught errors</b></summary>\n\nDoing nothing with a caught error doesn't give you the ability to ever fix or react to said error. Throwing the error isn't much better as often times it can get lost in a sea of things printed to the console. If you wrap any bit of code in a `try/catch` it means you think an error may occur there and therefore you should have a plan, or create a code path, for when it occurs.\n\n**Bad:**\n\n```csharp\ntry\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception ex)\n{\n    // silent exception\n}\n```\n\n**Good:**\n\n```csharp\ntry\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    NotifyUserOfError(error);\n\n    // Another option\n    ReportErrorToService(error);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Use multiple catch block instead of if conditions.</b></summary>\n\nIf you need to take action according to type of the exception,\nyou better use multiple catch block for exception handling.\n\n**Bad:**\n\n```csharp\ntry\n{\n    // Do something..\n}\ncatch (Exception ex)\n{\n\n    if (ex is TaskCanceledException)\n    {\n        // Take action for TaskCanceledException\n    }\n    else if (ex is TaskSchedulerException)\n    {\n        // Take action for TaskSchedulerException\n    }\n}\n```\n\n**Good:**\n\n```csharp\ntry\n{\n    // Do something..\n}\ncatch (TaskCanceledException ex)\n{\n    // Take action for TaskCanceledException\n}\ncatch (TaskSchedulerException ex)\n{\n    // Take action for TaskSchedulerException\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Keep exception stack trace when rethrowing exceptions</b></summary>\n\nC# allows the exception to be rethrown in a catch block using the `throw` keyword. It is a bad practice to throw a caught exception using `throw e;`. This statement resets the stack trace. Instead use `throw;`. This will keep the stack trace and provide a deeper insight about the exception.\nAnother option is to use a custom exception. Simply instantiate a new exception and set its inner exception property to the caught exception with throw `new CustomException(\"some info\", e);`. Adding information to an exception is a good practice as it will help with debugging. However, if the objective is to log an exception then use `throw;` to pass the buck to the caller.\n\n**Bad:**\n\n```csharp\ntry\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception ex)\n{\n    logger.LogInfo(ex);\n    throw ex;\n}\n```\n\n**Good:**\n\n```csharp\ntry\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    logger.LogInfo(error);\n    throw;\n}\n```\n\n**Good:**\n\n```csharp\ntry\n{\n    FunctionThatMightThrow();\n}\ncatch (Exception error)\n{\n    logger.LogInfo(error);\n    throw new CustomException(error);\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Formatting\n\n<details>\n  <summary><b>Uses <i>.editorconfig</i> file</b></summary>\n\n**Bad:**\n\nHas many code formatting styles in the project. For example, indent style is `space` and `tab` mixed in the project.\n\n**Good:**\n\nDefine and maintain consistent code style in your codebase with the use of an `.editorconfig` file\n\n```csharp\nroot = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n# C# files\n[*.cs]\nindent_size = 4\n# New line preferences\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_within_query_expression_clauses = true\n\n# Code files\n[*.{cs,csx,vb,vbx}]\nindent_size = 4\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = one_less_than_current\n\n# avoid this. unless absolutely necessary\ndotnet_style_qualification_for_field = false:suggestion\ndotnet_style_qualification_for_property = false:suggestion\ndotnet_style_qualification_for_method = false:suggestion\ndotnet_style_qualification_for_event = false:suggestion\n\n# only use var when it's obvious what the variable type is\n# csharp_style_var_for_built_in_types = false:none\n# csharp_style_var_when_type_is_apparent = false:none\n# csharp_style_var_elsewhere = false:suggestion\n\n# use language keywords instead of BCL types\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# name all constant fields using PascalCase\ndotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields\ndotnet_naming_rule.constant_fields_should_be_pascal_case.style    = pascal_case_style\n\ndotnet_naming_symbols.constant_fields.applicable_kinds   = field\ndotnet_naming_symbols.constant_fields.required_modifiers = const\n\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\n\n# static fields should have s_ prefix\ndotnet_naming_rule.static_fields_should_have_prefix.severity = suggestion\ndotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields\ndotnet_naming_rule.static_fields_should_have_prefix.style    = static_prefix_style\n\ndotnet_naming_symbols.static_fields.applicable_kinds   = field\ndotnet_naming_symbols.static_fields.required_modifiers = static\n\ndotnet_naming_style.static_prefix_style.required_prefix = s_\ndotnet_naming_style.static_prefix_style.capitalization = camel_case\n\n# internal and private fields should be _camelCase\ndotnet_naming_rule.camel_case_for_private_internal_fields.severity = suggestion\ndotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields\ndotnet_naming_rule.camel_case_for_private_internal_fields.style    = camel_case_underscore_style\n\ndotnet_naming_symbols.private_internal_fields.applicable_kinds = field\ndotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal\n\ndotnet_naming_style.camel_case_underscore_style.required_prefix = _\ndotnet_naming_style.camel_case_underscore_style.capitalization = camel_case\n\n# Code style defaults\ndotnet_sort_system_directives_first = true\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = false\n\n# Expression-level preferences\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\n\n# Expression-bodied members\ncsharp_style_expression_bodied_methods = false:none\ncsharp_style_expression_bodied_constructors = false:none\ncsharp_style_expression_bodied_operators = false:none\ncsharp_style_expression_bodied_properties = true:none\ncsharp_style_expression_bodied_indexers = true:none\ncsharp_style_expression_bodied_accessors = true:none\n\n# Pattern matching\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\n\n# Null checking preferences\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Space preferences\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = do_not_ignore\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n[*.{asm,inc}]\nindent_size = 8\n\n# Xml project files\n[*.{csproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]\nindent_size = 2\n\n# Xml config files\n[*.{props,targets,config,nuspec}]\nindent_size = 2\n\n[CMakeLists.txt]\nindent_size = 2\n\n[*.cmd]\nindent_size = 2\n\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n## Comments\n\n<details>\n  <summary><b>Avoid positional markers</b></summary>\n\nThey usually just add noise. Let the functions and variable names along with the proper indentation and formatting give the visual structure to your code.\n\n**Bad:**\n\n```csharp\n////////////////////////////////////////////////////////////////////////////////\n// Scope Model Instantiation\n////////////////////////////////////////////////////////////////////////////////\nvar model = new[]\n{\n    menu: 'foo',\n    nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Action setup\n////////////////////////////////////////////////////////////////////////////////\nvoid Actions()\n{\n    // ...\n};\n```\n\n**Bad:**\n\n```csharp\n\n#region Scope Model Instantiation\n\nvar model = {\n    menu: 'foo',\n    nav: 'bar'\n};\n\n#endregion\n\n#region Action setup\n\nvoid Actions() {\n    // ...\n};\n\n#endregion\n```\n\n**Good:**\n\n```csharp\nvar model = new[]\n{\n    menu: 'foo',\n    nav: 'bar'\n};\n\nvoid Actions()\n{\n    // ...\n};\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't leave commented out code in your codebase</b></summary>\n\nVersion control exists for a reason. Leave old code in your history.\n\n**Bad:**\n\n```csharp\ndoStuff();\n// doOtherStuff();\n// doSomeMoreStuff();\n// doSoMuchStuff();\n```\n\n**Good:**\n\n```csharp\ndoStuff();\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Don't have journal comments</b></summary>\n\nRemember, use version control! There's no need for dead code, commented code, and especially journal comments. Use `git log` to get history!\n\n**Bad:**\n\n```csharp\n/**\n * 2018-12-20: Removed monads, didn't understand them (RM)\n * 2017-10-01: Improved using special monads (JP)\n * 2016-02-03: Removed type-checking (LI)\n * 2015-03-14: Added combine with type-checking (JR)\n */\npublic int Combine(int a,int b)\n{\n    return a + b;\n}\n```\n\n**Good:**\n\n```csharp\npublic int Combine(int a,int b)\n{\n    return a + b;\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n<details>\n  <summary><b>Only comment things that have business logic complexity</b></summary>\n\nComments are an apology, not a requirement. Good code _mostly_ documents itself.\n\n**Bad:**\n\n```csharp\npublic int HashIt(string data)\n{\n    // The hash\n    var hash = 0;\n\n    // Length of string\n    var length = data.length;\n\n    // Loop through every character in data\n    for (var i = 0; i < length; i++)\n    {\n        // Get character code.\n        const char = data.charCodeAt(i);\n        // Make the hash\n        hash = ((hash << 5) - hash) + char;\n        // Convert to 32-bit integer\n        hash &= hash;\n    }\n}\n```\n\n**Better but still Bad:**\n\n```csharp\npublic int HashIt(string data)\n{\n    var hash = 0;\n    var length = data.length;\n    for (var i = 0; i < length; i++)\n    {\n        const char = data.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n\n        // Convert to 32-bit integer\n        hash &= hash;\n    }\n}\n```\n\nIf a comment explains WHAT the code is doing, it is probably a useless comment and can be implemented with a well named variable or function. The comment in the previous code could be replaced with a function named `ConvertTo32bitInt` so this comment is still useless.\nHowever it would be hard to express by code WHY the developer chose djb2 hash algorithm instead of sha-1 or another hash function. In that case a comment is acceptable.\n\n**Good:**\n\n```csharp\npublic int Hash(string data)\n{\n    var hash = 0;\n    var length = data.length;\n\n    for (var i = 0; i < length; i++)\n    {\n        var character = data[i];\n        // use of djb2 hash algorithm as it has a good compromise\n        // between speed and low collision with a very simple implementation\n        hash = ((hash << 5) - hash) + character;\n\n        hash = ConvertTo32BitInt(hash);\n    }\n    return hash;\n}\n\nprivate int ConvertTo32BitInt(int value)\n{\n    return value & value;\n}\n```\n\n**[\u2b06 back to top](#table-of-contents)**\n\n</details>\n\n# Other Clean Code Resources\n\n## Other Clean Code Lists\n\n- [clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript) - Clean Code concepts adapted for JavaScript\n- [clean-code-php](https://github.com/jupeter/clean-code-php) - Clean Code concepts adapted for PHP\n- [clean-code-ruby](https://github.com/uohzxela/clean-code-ruby) - Clean Code concepts adapted for Ruby\n- [clean-code-python](https://github.com/zedr/clean-code-python) - Clean Code concepts adapted for Python\n- [clean-code-typescript](https://github.com/labs42io/clean-code-typescript) - Clean Code concepts adapted for TypeScript\n- [clean-go-article](https://github.com/Pungyeon/clean-go-article) - Clean Code concepts adapted for Golang and an example how to apply [clean code in Golang](https://github.com/Pungyeon/clean-go)\n- [clean-abap](https://github.com/SAP/styleguides) - Clean Code concepts adapted for ABAP\n- [programming-principles](https://github.com/webpro/programming-principles) - Categorized overview of Programming Principles & Patterns\n- [Elixir-Code-Smells](https://github.com/lucasvegi/Elixir-Code-Smells) - Catalog of Elixir-specific code smells\n- [awesome-clean-code](https://github.com/kkisiele/awesome-clean-code) - Design principles, featured articles, tutorials, videos, code examples, blogs and books\n\n## Style Guides\n- [Google Styleguides](https://github.com/google/styleguide) - This project holds the C++ Style Guide, Swift Style Guide, Objective-C Style Guide, Java Style Guide, Python Style Guide, R Style Guide, Shell Style Guide, HTML/CSS Style Guide, JavaScript Style Guide, AngularJS Style Guide, Common Lisp Style Guide, and Vimscript Style Guide\n- [Django Styleguide](https://github.com/HackSoftware/Django-Styleguide) - Django styleguide used in HackSoft projects\n\n## Tools\n\n- [codemaid](https://github.com/codecadwallader/codemaid) - open source Visual Studio extension to cleanup and simplify our C#, C++, F#, VB, PHP, PowerShell, JSON, XAML, XML, ASP, HTML, CSS, LESS, SCSS, JavaScript and TypeScript coding\n- [Sharpen](https://github.com/sharpenrocks/Sharpen) - Visual Studio extension that intelligently introduces new C# features into your existing code base\n- [tslint-clean-code](https://github.com/Glavin001/tslint-clean-code) - TSLint rules for enforcing Clean Code\n\n## Cheatsheets\n\n- [AspNetCoreDiagnosticScenarios](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios) - Examples of broken patterns in ASP.NET Core applications\n- [Clean Code](cheatsheets/Clean-Code-V2.4.pdf) - The summary of [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/dp/0132350882) book\n- [Clean Architecture](cheatsheets/Clean-Architecture-V1.0.pdf) - The summary of [Clean Architecture: A Craftsman's Guide to Software Structure and Design](https://www.amazon.com/dp/0134494164) book\n- [Modern JavaScript Cheatsheet](https://github.com/mbeaudru/modern-js-cheatsheet) - Cheatsheet for the JavaScript knowledge you will frequently encounter in modern projects\n- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org) - Cheatsheet was created to provide a concise collection of high value information on specific application security topics\n- [.NET Memory Performance Analysis](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md) - This document aims to help folks who develop applications in .NET with how to think about memory performance analysis and finding the right approaches to perform such analysis if they need to. In this context .NET includes .NET Framework and .NET Core. In order to get the latest memory improvements in both the garbage collector and the rest of the framework I strongly encourage you to be on .NET Core if you are not already, because that\u2019s where the active development happens\n- [naming-cheatsheet](https://github.com/kettanaito/naming-cheatsheet) - Comprehensive language-agnostic guidelines on variables naming\n- [101 Design Patterns & Tips for Developers](https://sourcemaking.com/design-patterns-and-tips)\n- [Go Concurrency Guide](https://github.com/luk4z7/go-concurrency-guide)\n\n---\n\n# Contributors\n\nThank you to all the people who have already contributed to `clean-code-dotnet` project\n\n<a href=\"https://github.com/thangchung/clean-code-dotnet/graphs/contributors\"><img src=\"https://opencollective.com/cleancodedotnet/contributors.svg?width=890\" title=\"contributors\" alt=\"contributors\" /></a>\n\n# Backers\n\nLove our work and help us continue our activities? [[Become a backer](https://opencollective.com/cleancodedotnet#backer)]\n\n<a href=\"https://opencollective.com/cleancodedotnet#backers\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/backers.svg?width=890\"></a>\n\n# Sponsors\n\nBecome a sponsor and get your logo in our README on Github with a link to your site. [[Become a sponsor](https://opencollective.com/cleancodedotnet#sponsor)]\n\n<a href=\"https://opencollective.com/cleancodedotnet/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/cleancodedotnet/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/cleancodedotnet/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/cleancodedotnet/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/cleancodedotnet/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/cleancodedotnet/sponsor/4/avatar.svg\"></a>\n\n# License\n\n[![CC0](http://mirrors.creativecommons.org/presskit/buttons/88x31/svg/cc-zero.svg)](https://creativecommons.org/publicdomain/zero/1.0/)\n\nTo the extent possible under law, [thangchung](https://github.com/thangchung) has waived all copyright and related or neighboring rights to this work.\n"
}