{
  "repo_name": "hanickadot_compile-time-regular-expressions",
  "readme_content": "# Compile time regular expressions v3\n\n[![Build Status](https://travis-ci.org/hanickadot/compile-time-regular-expressions.svg?branch=master)](https://travis-ci.org/hanickadot/compile-time-regular-expressions)\n\nFast compile-time regular expressions with support for matching/searching/capturing during compile-time or runtime.\n\nYou can use the single header version from directory `single-header`. This header can be regenerated with `make single-header`. If you are using cmake, you can add this directory as subdirectory and link to target `ctre`.\n\nMore info at [compile-time.re](https://compile-time.re/)\n\n## What this library can do\n\n```c++\nctre::match<\"REGEX\">(subject); // C++20\n\"REGEX\"_ctre.match(subject); // C++17 + N3599 extension\n```\n\n* Matching\n* Searching (`search` or `starts_with`)\n* Capturing content (named captures are supported too)\n* Back-Reference (\\g{N} syntax, and \\1...\\9 syntax too)\n* Multiline support (with `multi_`) functions\n* Unicode properties and UTF-8 support\n\nThe library is implementing most of the PCRE syntax with a few exceptions:\n\n* callouts\n* comments\n* conditional patterns\n* control characters (`\\cX`)\n* match point reset (`\\K`)\n* named characters\n* octal numbers\n* options / modes\n* subroutines\n* unicode grapheme cluster (`\\X`)\n\nMore documentation on [pcre.org](https://www.pcre.org/current/doc/html/pcre2syntax.html).\n\n### Unknown character escape behaviour\n\nNot all escaped characters are automatically inserted as self, behaviour of the library is escaped characters are with special meaning, unknown escaped character is a syntax error.\n\nExplicitly allowed character escapes which insert only the character are:\n\n```\\-\\\"\\<\\>```\n\n## Basic API\n\nThis is approximated API specification from a user perspective (omitting `constexpr` and `noexcept` which are everywhere, and using C++20 syntax even the API is C++17 compatible):\n```c++\n// look if whole input matches the regex:\ntemplate <fixed_string regex> auto ctre::match(auto Range &&) -> regex_results;\ntemplate <fixed_string regex> auto ctre::match(auto First &&, auto Last &&) -> regex_results;\n\n// look if input contains match somewhere inside of itself:\ntemplate <fixed_string regex> auto ctre::search(auto Range &&) -> regex_results;\ntemplate <fixed_string regex> auto ctre::search(auto First &&, auto Last &&) -> regex_results;\n\n// check if input starts with match (but doesn't need to match everything):\ntemplate <fixed_string regex> auto ctre::starts_with(auto Range &&) -> regex_results;\ntemplate <fixed_string regex> auto ctre::starts_with(auto First &&, auto Last &&) -> regex_results;\n\n// result type is deconstructible into a structured bindings\ntemplate <...> struct regex_results {\n\toperator bool() const; // if it's a match\n\tauto to_view() const -> std::string_view; // also view()\n\tauto to_string() const -> std::string; // also str()\n\toperator std::string_view() const; // also supports all char variants\n\texplicit operator std::string() const;\n\t\n\t// also size(), begin(), end(), data()\n\t\n\tsize_t count() const; // number of captures \n\ttemplate <size_t Id> const captured_content & get() const; // provide specific capture, whole regex_results is implicit capture 0\n};\n```\n\n### Range outputing API\n\n```c++\n// search for regex in input and return each occurence, ignoring rest:\ntemplate <fixed_string regex> auto ctre::range(auto Range &&) -> range of regex_result;\ntemplate <fixed_string regex> auto ctre::range(auto First &&, auto Last &&) -> range of regex_result;\n\n// return range of each match, stopping at something which can't be matched\ntemplate <fixed_string regex> auto ctre::tokenize(auto Range &&) -> range of regex_result;\ntemplate <fixed_string regex> auto ctre::tokenize(auto First &&, auto Last &&) -> range of regex_result;\n\n// return parts of the input splited by the regex, returning it as part of content of the implicit zero capture (other captures are not changed, you can use it to access how the values were splitted):\ntemplate <fixed_string regex> auto ctre::split(auto Range &&) -> regex_result;\ntemplate <fixed_string regex> auto ctre::split(auto First &&, auto Last &&) -> range of regex_result;\n```\n\n### Functors\n\nAll the functions (`ctre::match`, `ctre::search`, `ctre::starts_with`, `ctre::range`, `ctre::tokenize`, `ctre::split`) are functors and can be used without parenthesis:\n\n```c++\nauto matcher = ctre::match<\"regex\">;\nif (matcher(input)) ...\n```\n\n### Possible subjects (inputs)\n\n* `std::string`-like objects (`std::string_view` or your own string if it's providing `begin`/`end` functions with forward iterators)\n* pairs of forward iterators\n\n### Unicode support\n\nTo enable you need to include:\n* `<ctre-unicode.hpp>`\n* or `<ctre.hpp>` and `<unicode-db.hpp>`\n\nOtherwise you will get missing symbols if you try to use the unicode support without enabling it.\n\n## Supported compilers\n\n* clang 7.0+ (template UDL, C++17 syntax)\n* xcode clang 10.0+ (template UDL, C++17 syntax)\n* clang 12.0+ (C++17 syntax, C++20 cNTTP syntax)\n* gcc 8.0+ (template UDL, C++17 syntax)\n* gcc 9.0+ (C++17 & C++20 cNTTP syntax)\n* MSVC 14.29+ (Visual Studio 16.11+) (C++20) \n\n### Template UDL syntax\n\nThe compiler must support extension N3599, for example as GNU extension in gcc (not in GCC 9.1+) and clang.\n\n```c++\nconstexpr auto match(std::string_view sv) noexcept {\n    using namespace ctre::literals;\n    return \"h.*\"_ctre.match(sv);\n}\n```\n\nIf you need extension N3599 in GCC 9.1+, you can't use -pedantic. Also, you need to define macro `CTRE_ENABLE_LITERALS`.\n\n### C++17 syntax\n\nYou can provide a pattern as a `constexpr ctll::fixed_string` variable.\n\n```c++\nstatic constexpr auto pattern = ctll::fixed_string{ \"h.*\" };\n\nconstexpr auto match(std::string_view sv) noexcept {\n    return ctre::match<pattern>(sv);\n}\n```\n\n(this is tested in MSVC 15.8.8)\n\n### C++20 syntax\n\nCurrently, the only compiler which supports cNTTP syntax `ctre::match<PATTERN>(subject)` is GCC 9+.\n\n```c++\nconstexpr auto match(std::string_view sv) noexcept {\n    return ctre::match<\"h.*\">(sv);\n}\n```\n\n## Examples\n\n### Extracting number from input\n\n```c++\nstd::optional<std::string_view> extract_number(std::string_view s) noexcept {\n    if (auto m = ctre::match<\"[a-z]+([0-9]+)\">(s)) {\n        return m.get<1>().to_view();\n    } else {\n        return std::nullopt;\n    }\n}\n```\n\n[link to compiler explorer](https://gcc.godbolt.org/z/5U67_e)\n\n### Extracting values from date\n\n```c++\nstruct date { std::string_view year; std::string_view month; std::string_view day; };\n\nstd::optional<date> extract_date(std::string_view s) noexcept {\n    using namespace ctre::literals;\n    if (auto [whole, year, month, day] = ctre::match<\"(\\\\d{4})/(\\\\d{1,2})/(\\\\d{1,2})\">(s); whole) {\n        return date{year, month, day};\n    } else {\n        return std::nullopt;\n    }\n}\n\n//static_assert(extract_date(\"2018/08/27\"sv).has_value());\n//static_assert((*extract_date(\"2018/08/27\"sv)).year == \"2018\"sv);\n//static_assert((*extract_date(\"2018/08/27\"sv)).month == \"08\"sv);\n//static_assert((*extract_date(\"2018/08/27\"sv)).day == \"27\"sv);\n```\n\n[link to compiler explorer](https://gcc.godbolt.org/z/x64CVp)\n\n### Using captures\n\n```c++\nauto result = ctre::match<\"(?<year>\\\\d{4})/(?<month>\\\\d{1,2})/(?<day>\\\\d{1,2})\">(s);\nreturn date{result.get<\"year\">(), result.get<\"month\">, result.get<\"day\">};\n\n// or in C++ emulation, but the object must have a linkage\nstatic constexpr ctll::fixed_string year = \"year\";\nstatic constexpr ctll::fixed_string month = \"month\";\nstatic constexpr ctll::fixed_string day = \"day\";\nreturn date{result.get<year>(), result.get<month>, result.get<day>};\n\n// or use numbered access\n// capture 0 is the whole match\nreturn date{result.get<1>(), result.get<2>, result.get<3>};\n```\n\n### Lexer\n\n```c++\nenum class type {\n    unknown, identifier, number\n};\n\nstruct lex_item {\n    type t;\n    std::string_view c;\n};\n\nstd::optional<lex_item> lexer(std::string_view v) noexcept {\n    if (auto [m,id,num] = ctre::match<\"([a-z]+)|([0-9]+)\">(v); m) {\n        if (id) {\n            return lex_item{type::identifier, id};\n        } else if (num) {\n            return lex_item{type::number, num};\n        }\n    }\n    return std::nullopt;\n}\n```\n\n[link to compiler explorer](https://gcc.godbolt.org/z/PKTiCC)\n\n### Range over input\n\nThis support is preliminary, probably the API will be changed.\n\n```c++\nauto input = \"123,456,768\"sv;\n\nfor (auto match: ctre::range<\"([0-9]+),?\">(input)) {\n    std::cout << std::string_view{match.get<0>()} << \"\\n\";\n}\n```\n\n### Unicode\n\n```c++\n#include <ctre-unicode.hpp>\n#include <iostream>\n// needed if you want to output to the terminal\nstd::string_view cast_from_unicode(std::u8string_view input) noexcept {\n    return std::string_view(reinterpret_cast<const char *>(input.data()), input.size());\n}\nint main()\n{\n    using namespace std::literals;\n    std::u8string_view original = u8\"Tu es un g\u00e9nie\"sv;\n\n    for (auto match : ctre::range<\"\\\\p{Letter}+\">(original))\n        std::cout << cast_from_unicode(match) << std::endl;\n    return 0;\n}\n```\n\n[link to compiler explorer](https://godbolt.org/z/erTshe6sz)\n\n\n## Installing ctre using vcpkg\n\nYou can download and install ctre using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n```bash\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install ctre\n```\n\nThe ctre port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n## Running tests (for developers)\n\nJust run `make` in root of this project.\n"
}