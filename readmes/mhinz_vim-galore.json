{
  "repo_name": "mhinz_vim-galore",
  "readme_content": "<div align='center'>\n  <br /><br /><br />\n  <img src='https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/logo-vim-galore.png' alt='vim-galore logo' />\n  <br /><br /><br /><br />\n  <div>\n    <a href='https://github.com/wsdjeg/vim-galore-zh_cn'>Chinese</a> |\n    <a href='http://postd.cc/?s=vim-galore'>Japanese</a> |\n    <a href='https://github.com/lsrdg/vim-galore'>Portuguese</a> |\n    <a href='http://givi.olnd.ru/vim-galore/vim-galore-ru.html'>Russian</a> |\n    <a href='https://github.com/kyoz/vim-galore-vi'>Vietnamese</a>\n    <div>\n      <br />\n      <sub>Licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0'>CC BY-SA 4.0<a/>.</sub>\n    </div>\n  </div>\n  <br /><br />\n</div>\n\n### [Intro](#intro-1)\n\n- [What is Vim?](#what-is-vim)\n- [The Vim Philosophy](#the-vim-philosophy)\n- [First steps](#first-steps)\n- [Minimal vimrc](#minimal-vimrc)\n- [What kind of Vim am I running?](#what-kind-of-vim-am-i-running)\n- [Cheatsheets](#cheatsheets)\n\n### [Basics](#basics-1)\n\n- [Buffers, windows, tabs](#buffers-windows-tabs)\n- [Active, loaded, listed, named buffers](#active-loaded-listed-named-buffers)\n- [Argument list](#argument-list)\n- [Mappings](#mappings)\n- [Mapleader](#mapleader)\n- [Registers](#registers)\n- [Ranges](#ranges)\n- [Marks](#marks)\n- [Completion](#completion)\n- [Motions, operators, text objects](#motions-operators-text-objects)\n- [Autocmds](#autocmds)\n- [Changelist, jumplist](#changelist-jumplist)\n- [Undo tree](#undo-tree)\n- [Quickfix and location lists](#quickfix-and-location-lists)\n- [Macros](#macros)\n- [Colorschemes](#colorschemes)\n- [Folding](#folding)\n- [Sessions](#sessions)\n- [Locality](#locality)\n\n### [Usage](#usage-1)\n\n- [Getting help offline](#getting-help-offline)\n- [Getting help offline (alternative)](#getting-help-offline-alternative)\n- [Getting help online](#getting-help-online)\n- [Autocmds in practice](#autocmds-in-practice)\n  - [User events](#user-events)\n  - [Nested autocmds](#nested-autocmds)\n- [Clipboard](#clipboard)\n  - [Clipboard usage (Windows, macOS)](#clipboard-usage-windows-macos)\n  - [Clipboard usage (Linux, BSD, ...)](#clipboard-usage-linux-bsd-)\n- [Restore cursor position when opening file](#restore-cursor-position-when-opening-file)\n- [Temporary files](#temporary-files)\n  - [Backup files](#backup-files)\n  - [Swap files](#swap-files)\n  - [Undo files](#undo-files)\n  - [Viminfo files](#viminfo-files)\n  - [Example configuration for temporary files](#example-configuration-for-temporary-files)\n- [Editing remote files](#editing-remote-files)\n- [Managing plugins](#managing-plugins)\n- [Block insert](#block-insert)\n- [Running external programs and using filters](#running-external-programs-and-using-filters)\n- [Cscope](#cscope)\n- [MatchIt](#matchit)\n- [True colors](#true-colors)\n\n### [Tips](#tips-1)\n\n- [Go to other end of selected text](#go-to-other-end-of-selected-text)\n- [Saner behavior of n and N](#saner-behavior-of-n-and-n)\n- [Saner command-line history](#saner-command-line-history)\n- [Saner CTRL-L](#saner-ctrl-l)\n- [Disable audible and visual bells](#disable-audible-and-visual-bells)\n- [Quickly move current line](#quickly-move-current-line)\n- [Quickly add empty lines](#quickly-add-empty-lines)\n- [Quickly edit your macros](#quickly-edit-your-macros)\n- [Quickly jump to header or source file](#quickly-jump-to-header-or-source-file)\n- [Quickly change font size in GUI](#quickly-change-font-size-in-gui)\n- [Change cursor style dependent on mode](#change-cursor-style-dependent-on-mode)\n- [Don't lose selection when shifting sidewards](#dont-lose-selection-when-shifting-sidewards)\n- [Reload a file on saving](#reload-a-file-on-saving)\n- [Smarter cursorline](#smarter-cursorline)\n- [Faster keyword completion](#faster-keyword-completion)\n- [Cosmetic changes to colorschemes](#cosmetic-changes-to-colorschemes)\n\n### [Commands](#commands-1)\n\n- [:global and :vglobal](#global-and-vglobal) - Execute a command on all matching lines.\n- [:normal and :execute](#normal-and-execute) - The scripting dream team.\n- [:redir and execute()](#redir-and-execute) - Capture command output.\n\n### [Debugging](#debugging-1)\n\n- [General tips](#general-tips)\n- [Verbosity](#verbosity)\n- [Profiling startup time](#profiling-startup-time)\n- [Profiling at runtime](#profiling-at-runtime)\n- [Debugging Vim scripts](#debugging-vim-scripts)\n- [Debugging syntax files](#debugging-syntax-files)\n\n### [Miscellaneous](#miscellaneous-1)\n\n- [Additional resources](#additional-resources)\n- [Vim distributions](#vim-distributions)\n- [Standard plugins](#standard-plugins)\n- [Map CapsLock to Control](#map-capslock-to-control)\n- [Generating HTML from buffer](#generating-html-from-buffer)\n- [Easter eggs](#easter-eggs)\n- [Why hjkl for navigation?](#why-hjkl-for-navigation)\n\n### [Common problems](#common-problems-1)\n\n- [Editing small files is slow](#editing-small-files-is-slow)\n- [Editing huge files is slow](#editing-huge-files-is-slow)\n- [Bracketed paste (or why do I have to set 'paste' all the time?)](#bracketed-paste-or-why-do-i-have-to-set-paste-all-the-time)\n- [Delays when using escape key in terminal](#delays-when-using-escape-key-in-terminal)\n- [Function search undo](#function-search-undo)\n\n### [Technical quirks](#technical-quirks-1)\n\n- [Newline used for NUL](#newline-used-for-nul)\n\n### [Terminology](#terminology-1)\n\n- [Vim script? Vimscript? VimL?](#vim-script-vimscript-viml)\n\n### [List of colorschemes](PLUGINS.md#colorschemes-1)\n\n### [List of plugins](PLUGINS.md)\n\n<br>\n\n# Intro\n\n## What is Vim?\n\n[Vim](http://www.vim.org) is a text editor with a long line of ancestors that\ngoes back to [qed](https://en.wikipedia.org/wiki/QED_(text_editor)). [Bram\nMoolenaar](https://en.wikipedia.org/wiki/Bram_Moolenaar) released it in 1991.\n\nThe project is hosted online at [vim.org](http://www.vim.org/index.php).\n\nGetting Vim: Use your favourite package manager or visit the [download\npage](http://www.vim.org/download.php) from vim.org.\n\nDiscussions and user questions are best done on the\n[vim_use](https://groups.google.com/forum/#!forum/vim_use) mailing list or using\nIRC ([Freenode](https://freenode.net)) in the `#vim` channel.\n\nDevelopment happens on [GitHub](https://github.com/vim/vim), discussions on the\n[vim_dev](https://groups.google.com/forum/#!forum/vim_dev) mailing list.\n\nRead [Why, oh WHY, do those #?@! nutheads use\nvi?](http://www.viemu.com/a-why-vi-vim.html) to see common misconceptions about\nVim explained.\n\n## The Vim Philosophy\n\nVim adheres to the modal editing philosophy. This means that it provides\nmultiple modes and the meaning of keys changes according to the mode. You\nnavigate files in _normal mode_, you insert text in _insert mode_, you select\nlines in _visual mode_, you access commands in _command-line mode_ and so on.\nThis might sound complicated at first, but has a huge advantage: you don't have\nto break your fingers by holding several keys at once, most of the time you\nsimply press them one after the other. The more common the task, the fewer keys\nare needed.\n\nA related concept that works well with modal editing are operators and motions.\n_Operators_ start a certain action, e.g. changing, removing, or selecting text.\nAfterwards you specify the region of text you want to act on using a _motion_.\nTo change everything between parentheses, use `ci(` (read _change inner\nparentheses_). To remove an entire paragraph of text, use `dap` (read _delete\naround paragraph_).\n\nIf you see advanced Vim users working, you'll notice that they speak the\n_language of Vim_ as well as pianists handle their instruments. Complex\noperations are done using only a few key presses. They don't even think about it\nanymore as [muscle memory](https://en.wikipedia.org/wiki/Muscle_memory) took\nover already. This reduces [cognitive\nload](https://en.wikipedia.org/wiki/Cognitive_load) and helps to focus on the\nactual task.\n\n## First steps\n\nVim comes bundled with an interactive tutorial that teaches the most basic\nthings you need to know about. You can start it from the shell:\n\n```\n$ vimtutor\n```\n\nDon't be put off by how boring it looks like and work through the exercises. The\neditors or IDEs you used before were most probably all non-modal, so working by\nswitching modes will seem awkward at first, but the more you use Vim, the more\nit becomes [muscle memory](https://en.wikipedia.org/wiki/Muscle_memory).\n\nVim was bolted on [Stevie](https://en.wikipedia.org/wiki/Stevie_(text_editor)), a\n[vi](https://en.wikipedia.org/wiki/Vi) clone, and supports two operating modes:\n\"compatible\" and \"nocompatible\". Using Vim in compatible mode means using vi\ndefaults for all options, opposed to Vim defaults. As long as you didn't create\na user vimrc yet or started Vim with `vim -N`, compatible mode is assumed! Don't\nuse Vim in compatible mode. Just don't.\n\nNext steps:\n\n1. Create your own [vimrc](#minimal-vimrc).\n2. Have some [cheatsheets](#cheatsheets) ready for the first weeks.\n3. Read through the [basics](#basics-1) section to learn what is even possible.\n4. Learn on demand! You never finish learning Vim. If you encounter any\n   problems, just look for it on the internet. Your problem was solved already.\n   Vim comes with great documentation and knowing how to navigate it is a must:\n   [Getting help offline](#getting-help-offline).\n5. Have a look at the [additional resources](#additional-resources).\n\nOne last advice: Please learn how to use Vim properly before starting to add all\nkinds of hyped [plugins](#managing-plugins) that only implement features that\nVim already supports natively.\n\n## Minimal vimrc\n\nThe user vimrc can be put into `~/.vimrc` or for the sake of better separation\ninto `~/.vim/vimrc`. The latter makes it easy to put the entire configuration\nunder version control and upload it to, let's say GitHub.\n\nYou find many \"minimal vimrcs\" all over the net, and maybe my version isn't as\nminimal as it should be, but it provides a good set of sane settings that I deem\nto be useful for starting out.\n\nEventually you have to read up on all the mentioned settings anyway and decide\nfor yourself. :-)\n\nSo here it is: [minimal-vimrc](static/minimal-vimrc.vim)\n\nIn case you're interested, here's\n[my vimrc](https://github.com/mhinz/dotfiles/blob/master/.vim/vimrc).\n\n**TIP**: Most plugin authors maintain several plugins and also publish their\nvimrc on GitHub (often in a repository called \"vim-config\" or \"dotfiles\"), so\nwhenever you find a plugin you like, look up its maintainer's GitHub page and\nlook through the repositories.\n\n## What kind of Vim am I running?\n\nLooking at `:version` will give you all the information you need to know about\nhow the currently running Vim binary was compiled.\n\nThe first line tells you when the binary was compiled and the version, e.g. 7.4.\nOne of the next lines states `Included patches: 1-1051`, which is the patch\nlevel. Thus, your exact Vim version is 7.4.1051.\n\nAnother line states something like `Tiny version without GUI` or `Huge version\nwith GUI`. The obvious information from that is whether your Vim includes GUI\nsupport, e.g. for starting `gvim` from the shell or running `:gui` from Vim\nwithin a terminal emulator. The other important information is the `Tiny` and\n`Huge`. Vim distinguishes between feature sets called `tiny`, `small`, `normal`,\n`big`, and `huge`, all enabling different subsets of features.\n\nThe majority of `:version` output is consumed by the feature list itself.\n`+clipboard` means the clipboard feature was compiled in, `-clipboard` means it\nwasn't compiled in.\n\nA few Vim features need to be compiled in for them to work. E.g. for `:prof` to\nwork, you need a Vim with a huge feature set, because that set enables the\n`+profile` feature.\n\nIf that's not the case and you installed Vim from a package manager, make sure\nto install a package called `vim-x`, `vim-x11`, `vim-gtk`, `vim-gnome` or\nsimilar, since these packages usually come with the huge feature set.\n\nYou can also test for the version or features programmatically:\n\n```vim\n\" Do something if running at least Vim 7.4.42 with +profile enabled.\nif (v:version > 704 || v:version == 704 && has('patch42')) && has('profile')\n  \" do stuff\nendif\n```\n\nHelp:\n\n```\n:h :version\n:h feature-list\n:h +feature-list\n:h has-patch\n```\n\n## Cheatsheets\n\n- http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png\n- https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png\n- http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png\n- http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png\n\nOr quickly open a cheatsheet from within Vim: [vim-cheat40](https://github.com/lifepillar/vim-cheat40).\n\n# Basics\n\n## Buffers, windows, tabs\n\nVim is a text editor. Every time text is shown, the text is part of a\n**buffer**. Each file will be opened in its own buffer. Plugins show stuff in\ntheir own buffers etc.\n\nBuffers have many attributes, e.g. whether the text it contains is modifiable,\nor whether it is associated with a file and thus needs to be synchronized to\ndisk on saving.\n\n**Windows** are viewports _onto_ buffers. If you want to view several files at\nthe same time or even different locations of the same file, you use windows.\n\nAnd please, please don't call them _splits_. You can split a window in two, but\nthat doesn't make them _splits_.\n\nWindows can be split vertically or horizontally and the heights and widths of\nexisting windows can be altered, too. Therefore, you can use whatever window\nlayout you prefer.\n\nA **tab page** (or just tab) is a collection of windows. Thus, if you want to\nuse multiple window layouts, use tabs.\n\nPutting it in a nutshell, if you start Vim without arguments, you'll have one\ntab page that holds one window that shows one buffer.\n\nBy the way, the buffer list is global and you can access any buffer from any\ntab.\n\n## Active, loaded, listed, named buffers\n\nRun Vim like this `vim file1`. The file's content will be loaded into a buffer.\nYou have a **loaded buffer** now. The content of the buffer is only synchronized\nto disk (written back to the file) if you save it within Vim.\n\nSince the buffer is also shown in a window, it's also an **active buffer**. Now\nif you load another file via `:e file2`, `file1` will become a **hidden buffer**\nand `file2` the active one.\n\nBoth buffers are also **listed**, thus they will get listed in the output of\n`:ls`. Plugin buffers or help buffers are often marked as unlisted, since\nthey're not regular files you usually edit with a text editor. Listed and\nunlisted buffers can be shown via `:ls!`.\n\n**Unnamed buffers**, also often used by plugins, are buffers that don't have an\nassociated filename. E.g. `:enew` will create an unnamed scratch buffer. Add\nsome text and write it to disk via `:w /tmp/foo`, and it will become a named\nbuffer.\n\n## Argument list\n\nThe [global buffer list](#buffers-windows-tabs) is a Vim thing. Before that, in\nvi, there only used to be the argument list, which is also available in Vim.\n\nEvery filename given to Vim on the shell command-line, is remembered in the\nargument list. There can be multiple argument lists: by default all arguments\nare put into the global argument list, but you can use `:arglocal` to create a\nnew argument list that is local to the window.\n\nList the current arguments with `:args`. Switch between files from the argument\nlist with `:next`, `:previous`, `:first`, `:last` and friends. Alter it with\n`:argadd`, `:argdelete` or `:args` with a list of files.\n\nIf you should prefer using the buffer or argument list for working with files is\na matter of taste. My impression is that most people use the buffer list\nexclusively.\n\nNevertheless, there is one huge use case for the argument list: batch processing\nvia `:argdo`! A simple refactoring example:\n\n```vim\n:args **/*.[ch]\n:argdo %s/foo/bar/ge | update\n```\n\nThis replaces all occurrences of \"foo\" by \"bar\" in all C source and header files\nfrom the current directory and below.\n\nHelp: `:h argument-list`\n\n## Mappings\n\nYou can define your own mappings with the `:map` family of commands. Each\ncommand of that family defines a mapping for a certain set of modes. Technically\nVim comes with a whopping 12 modes, 6 of them can be mapped. Additionally, some\ncommands act on multiple modes at once.\n\n| Recursive | Non-recursive | Unmap     | Modes                            |\n|-----------|---------------|-----------|----------------------------------|\n| `:map`    | `:noremap`    | `:unmap`  | normal, visual, operator-pending |\n| `:nmap`   | `:nnoremap`   | `:nunmap` | normal                           |\n| `:xmap`   | `:xnoremap`   | `:xunmap` | visual                           |\n| `:cmap`   | `:cnoremap`   | `:cunmap` | command-line                     |\n| `:omap`   | `:onoremap`   | `:ounmap` | operator-pending                 |\n| `:imap`   | `:inoremap`   | `:iunmap` | insert                           |\n\nE.g. this defines the mapping for normal mode only:\n\n```vim\n:nmap <space> :echo \"foo\"<cr>\n```\n\nUnmap it again by using `:nunmap <space>`.\n\nFor a few more but rather uncommon modes (or combinations of them), see `:h\nmap-modes`.\n\nSo far, so good. There's only one problem that can be pretty confusing to\nbeginners: `:nmap` is _recursive_! That is, the right-hand side takes other\nmappings into account.\n\nSo you defined a mapping that simply echoes \"Foo\":\n\n```vim\n:nmap b :echo \"Foo\"<cr>\n```\n\nBut what if you want to map the default behavior of `b` (going one word back) to\nanother key?\n\n```vim\n:nmap a b\n```\n\nIf you hit <kbd>a</kbd>, we expect the cursor to go back a word, but instead\n\"Foo\" is printed in the command-line! Because the right-hand side, `b`, was\nmapped to another action already, namely `:echo \"Foo\"<cr>`.\n\nThe proper way to resolve this problem is to use a _non-recursive_ mapping\ninstead:\n\n```vim\n:nnoremap a b\n```\n\nRule of thumb: Always use non-recursive mappings unless recursing is actually\ndesired.\n\nLook up your mappings by not giving a right-hand side. E.g. `:nmap` shows all\nnormal mappings and `:nmap <leader>` shows all normal mappings that start with\nthe mapleader.\n\nIf you want to disable a standard mapping, map them to the special `<nop>`\ncharacter, e.g. `:noremap <left> <nop>`.\n\nHelp:\n\n    :h key-notation\n    :h mapping\n    :h 05.3\n\n## Mapleader\n\nThe mapleader is simply a placeholder than can be used with custom mappings and\nis set to `\\` by default.\n\n```vim\nnnoremap <leader>h :helpgrep<space>\n```\n\nThis mapping is triggered by `\\h`. If you want to use `<space>h` instead:\n\n```vim\nlet mapleader = ' '\nnnoremap <leader>h :helpgrep<space>\n```\n\nMoreover, there is `<localleader>` that is the local counterpart to `<leader>`\nand is supposed to be used for mappings that are local to the buffer, eg.\nfiletype-specific plugins. It also defaults to `\\`.\n\n**Note**: Set the mapleaders before mappings! All leader mappings that are in\neffect already, won't change just because the mapleader was changed. `:nmap\n<leader>` will show all normal mode leader mappings with the mapleader resolved\nalready, so use it to double-check your mappings.\n\nSee `:h mapleader` and `:h maplocalleader` for more.\n\n## Registers\n\nRegisters are slots that save text. Copying text into a register is called\n**yanking** and extracting text from a register is called **pasting**.\n\nVim provides the following registers:\n\n| Type                | Character              | Filled by? | Readonly? | Contains text from? |\n|---------------------|------------------------|------------|-----------|---------------------|\n| Unnamed             | `\"`                    | vim        | [ ]       | Last yank or deletion. (`d`, `c`, `s`, `x`, `y`) |\n| Numbered            | `0` to `9`             | vim        | [ ]       | Register `0`: Last yank. Register `1`: Last deletion. Register `2`: Second last deletion. And so on. Think of registers `1`-`9` as a read-only [queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) with 9 elements. |\n| Small delete        | `-`                    | vim        | [ ]       | Last deletion that was less than one line. |\n| Named               | `a` to `z`, `A` to `Z` | user       | [ ]       | If you yank to register `a`, you replace its text. If you yank to register `A`, you append to the text in register `a`. |\n| Read-only           | `:`, `.`, `%`          | vim        | [x]       | `:`: Last command, `.`: Last inserted text, `%`: Current filename. |\n| Alternate buffer    | `#`                    | vim        | [ ]       | Most of the time the previously visited buffer of the current window. See `:h alternate-file` |\n| Expression          | `=`                    | user       | [ ]       | Evaluation of the VimL expression that was yanked. E.g. do this in insert mode: `<c-r>=5+5<cr>` and \"10\" will be inserted in the buffer. |\n| Selection           | `+`, `*`               | vim        | [ ]       | `*` and `+` are the [clipboard](#clipboard) registers. |\n| Drop                | `~`                    | vim        | [x]       | From last drag'n'drop. |\n| Black hole          | `_`                    | vim        | [ ]       | If you don't want any other registers implicitly affected. E.g. `\"_dd` deletes the current line without affecting registers `\"`, `1`, `+`, `*`. |\n| Last search pattern | `/`                    | vim        | [ ]       | Last pattern used with `/`, `?`, `:global`, etc. |\n\nEach register that is not readonly can be set by the user:\n\n```vim\n:let @/ = 'register'\n```\n\nAfterwards <kbd>n</kbd> would jump to the next occurrence of \"register\".\n\nThere are numerous exceptions when registers get implicitly filled, so be sure\nto read `:h registers`.\n\nYank with `y` and paste with `p`/`P`, but mind that Vim distinguishes between\ncharacterwise and linewise visual selections. See `:h linewise`.\n\n**Example: linewise**\n\n`yy` (or just `Y`) yanks the current line, move the cursor somewhere else, use\n`p` to paste below the current line `P` for pasting above it.\n\n**Example: charwise**\n\nYank the first word with `0yw`, move somewhere else, paste after the cursor on\nthe current line with `p` and before the cursor with `P`.\n\n**Example: explicit naming of register**\n\n`\"aY` yanks the current line into register `a`. Move to another line. `\"AY`\nappends the current line to register `a`.\n\nI suggest playing around with all these registers a bit and constantly checking\n`:reg`, so you can see what's actually happening.\n\n**Fun fact**: In Emacs \"yanking\" stands for pasting (or _reinserting previously\nkilled text_) not copying.\n\n## Ranges\n\nRanges are pretty easy to understand, but many Vimmers don't know about their\nfull potential.\n\n- Many commands take ranges.\n- An address denotes a certain line.\n- A range is either a single address or a pair of addresses separated by either\n  `,` or `;`.\n- Ranges tell commands which lines to act on.\n- Most commands act only on the current line by default. Notable exceptions are\n  `:write` and `:global` which act on all lines.\n\nThe usage of ranges is pretty intuitive, so here are some examples (using `:d`\nas short form of `:delete`):\n\n| Command | Lines acted on |\n|---------|----------------|\n| `:d` | Current line. |\n| `:.d` | Current line. |\n| `:1d` | First line. |\n| `:$d` | Last line. |\n| `:1,$d` | All lines. |\n| `:%d` | All lines (syntactic sugar for `1,$`). |\n| `:.,5d` | Current line to line 5. |\n| `:,5d` | Also current line to line 5. |\n| `:,+3d` | Current line and the next 3 lines. |\n| `:1,+3d` | First line to current line + 3. |\n| `:,-3d` | Current line and the last 3 lines. (Vim will prompt you, since this is a reversed range.) |\n| `:3,'xdelete` | Lines 3 to the line marked by [mark](#marks) x. |\n| `:/^foo/,$delete` | From the next line that starts with \"foo\" to the end. |\n| `:/^foo/+1,$delete` | From the line after the line that starts with \"foo\" to the end. |\n\nNote that instead of `,`, `;` can be used as a separator. The difference is that\nin the case of `from,to`, the _to_ is relative to the current line, but when\nusing `from;to`, the _to_ is relative to the address of _from_! Assuming you're\non line 5, `:1,+1d` would delete lines 1 to 6, whereas `:1;+1d` would only\ndelete lines 1 and 2.\n\nThe `/` address can be preceded with another address. This allows you to _stack_\npatterns, e.g.:\n\n```vim\n:/foo//bar//quux/d\n```\n\nThis would delete the first line containing \"quux\" after the first line\ncontaining \"bar\" after the first line containing \"foo\" after the current line.\n\nSometimes Vim automatically prepends the command-line with a range. E.g. start a\nvisual line selection with `V`, select some lines and type `:`. The command-line\nwill be populated with the range `'<,'>`, which means the following command will\nuse the previously selected lines as a range. (This is also why you sometimes\nsee mappings like `:vnoremap foo :<c-u>command`. Here `<c-u>` is used to remove\nthe range, because Vim will throw an error when giving a range to a command that\ndoesn't support it.)\n\nAnother example is using `!!` in normal mode. This will populate the\ncommand-line with `:.!`. If followed by an external program, that program's\noutput would replace the current line. So you could replace the current\nparagraph with the output of ls by using `:?^$?+1,/^$/-1!ls`. Fancy!\n\nHelp:\n\n```\n:h cmdline-ranges\n:h 10.3\n```\n\n## Marks\n\nYou use marks to remember a position, that is line number and column, in a file.\n\n| Marks | Set by.. | Usage |\n|-------|----------|-------|\n| `a` - `z` | User | Local to file, thus only valid within one file. Jumping to a lowercase mark, means jumping within the current file. |\n| `A` - `Z` | User | Global, thus valid between files. Also called _file marks_. Jumping to a file mark may switch to another buffer. |\n| `0` - `9` | viminfo | `0` is the position when the viminfo file was written last. In practice this means when the last Vim process ended. `1` is the position of when the second last Vim process ended and so on. |\n\nPut `'`/`g'` or `` ` ``/`` g` `` in front of a mark to form a motion.\n\nUse `mm` to remember the current position with mark \"m\". Move around the file\nand then jump back via `'m` (first non-blank) or `` `m `` (exact column).\nLowercase marks will be remembered after exiting Vim, if you tell your viminfo\nfile to do so, see `:h viminfo-'`.\n\nUse `mM` to remember the current position with file mark \"M\". Switch to another\nbuffer and switch back via `'M` or `` `M ``.\n\nOther motions include:\n\n| Motion           | Jump to.. |\n|------------------|-----------|\n| `'[`, `` `[ ``   | First line or character of previously changed or yanked text. |\n| `']`, `` `] ``   | Last line or character of previously changed or yanked text. |\n| `'<`, `` `< ``   | Beginning line or character of last visual selection. |\n| `'>`, `` `> ``   | Ending line or character of last visual selection. |\n| `''`, ``` `` ``` | Position before the latest jump. |\n| `'\"`, `` `\" ``   | Position when last exiting the current buffer. |\n| `'^`, `` `^ ``   | Position where last insertion stopped. |\n| `'.`, `` `. ``   | Position where last change was made. |\n| `'(`, `` `( ``   | Start of current sentence. |\n| `')`, `` `) ``   | End of current sentence. |\n| `'{`, `` `{ ``   | Start of current paragraph. |\n| `'}`, `` `} ``   | End of current paragraph. |\n\nMarks can also be used in a [range](#ranges). You probably saw this before and\nwondered what it means: Select some text in visual mode and do `:`, the\ncommand-line will be prepended with `:'<,'>`, which means the following command\nwould get a range that denotes the visual selection.\n\nUse `:marks` to list all marks. Read everything in `:h mark-motions`.\n\n## Completion\n\nVim provides many kinds of insert mode completions. If there are multiple\nmatches, a popup menu will let you navigate to the match of your choice.\n\nTypical kinds of completion are tags, functions from imported modules or\nlibraries, file names, dictionary or simply words from the current buffer.\n\nVim provides a mapping for each kind of completion and they all start with\n`<c-x>` (remember to use them in insert mode):\n\n| Mapping | Kind | Help         |\n|---------|------|--------------|\n| `<c-x><c-l>` | whole lines | `:h i^x^l` |\n| `<c-x><c-n>` | keywords from current file | `:h i^x^n` |\n| `<c-x><c-k>` | keywords from `'dictionary'` option | `:h i^x^k` |\n| `<c-x><c-t>` | keywords from `'thesaurus'` option | `:h i^x^t` |\n| `<c-x><c-i>` | keywords from current and included files | `:h i^x^i` |\n| `<c-x><c-]>` | tags | `:h i^x^]` |\n| `<c-x><c-f>` | file names | `:h i^x^f` |\n| `<c-x><c-d>` | definitions or macros | `:h i^x^d` |\n| `<c-x><c-v>` | Vim commands | `:h i^x^v` |\n| `<c-x><c-u>` | user defined (as specified in `'completefunc'`) | `:h i^x^u` |\n| `<c-x><c-o>` | omni completion (as specified in `'omnifunc'`) | `:h i^x^o` |\n| `<c-x>s`     | spelling suggestions | `:h i^Xs` |\n\nPeople might be confused about the difference between user defined completion\nand omni completion, but technically they do the same thing. They take a\nfunction that inspects the current position and return a list of suggestions.\nUser defined completion is defined by the user for their own personal purposes.\n(Surprise!) It could be anything. Omni completion is meant for filetype-specific\npurposes, like completing struct members or class methods, and is often set by\nfiletype plugins.\n\nVim also allows for completing multiple kinds at once by setting the\n`'complete'` option. By default that option includes quite a lot, so be sure to\ntrim it to your taste. You can trigger this completion by using either `<c-n>`\n(next) and `<c-p>` (previous), which also happen to be the keys used for\nchoosing entries in the popup menu. See `:h i^n` and `:h 'complete'` for more on\nthis.\n\nBe sure to check out `:h 'completeopt'` for configuring the behaviour of the\npopup menu. The default is quite sane, but I prefer adding \"noselect\" as well.\n\nHelp:\n\n```\n:h ins-completion\n:h popupmenu-keys\n:h new-omni-completion\n```\n\n## Motions, operators, text objects\n\n**Motions** move the cursor. You all know `h`/`j`/`k`/`l`. Or `w` and `b`. Even\n`/` is a motion. They also take a count. `2?the<cr>` jumps to the second last\noccurrence of \"the\".\n\nSee `:h navigation` and everything below for all available motions.\n\n**Operators** act on a region of text, e.g. `d`, `~`, `gU`, `>` to name just a\nfew. They get used in two contexts, either in normal or visual mode. In normal\nmode, operators come first followed by a motion, e.g. `>j`. In visual mode,\noperators simply act on the selection, e.g. `Vjd`.\n\nLike motions, operators take a count, e.g. `2gUw` makes the rest of the current\nword and the next one uppercase. Since motions and operators take counts,\n`2gU2w` works just as well and executes `gU2w` twice.\n\nSee `:h operator` for all available operators. Use `:set tildeop` to make `~`\nact as an operator.\n\n**Text objects** act on the surrounding area, opposed to motions that act into\none direction. Actually they work on objects, e.g. a whole word, a whole\nsentence, everything between parentheses, and so on.\n\nText objects can't be used to move the cursor in normal mode, because even the\nmost-skilled cursors can't jump into two directions at the same time. It works\nin visual mode though, because then one side of the object is already selected\nand the cursor simply jumps to the other side.\n\nText objects start with either `i` (think _inner_) or `a` (think _around_)\nfollowed by a character denoting the object. With `i` it only acts on the object\nitself, with `a` on the object plus trailing whitespace. E.g. `diw` deletes the\ncurrent word and `ci(` changes everything between parentheses.\n\nText objects take a count. Imagine `((( )))` and the cursor on or between the\nmost inner parentheses, then `d2a(` will remove the 2 inner pairs of parentheses\nand everything in between.\n\nSee `:h text-objects` for all available text objects.\n\n## Autocmds\n\nYou can trigger an action after many events in Vim, such as a buffer being\nsaved or Vim having started up, by so-called _autocmds_.\n\nVim relies extensively on autocmds. Don't believe me? Check `:au`, but don't let\nthe output overwhelm you. These are all the autocmds that are in effect right\nnow!\n\nSee `:h {event}` for a quick overview of all available events and `:h\nautocmd-events-abc` for more details.\n\nA typical example would be filetype-specific settings:\n\n```vim\nautocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:#\n```\n\nBut how does a buffer even know that it contains Ruby code? Because another\nautocmd detected it as that and set the filetype accordingly which again\ntriggered the `FileType` event.\n\nOne of the first things everyone adds to their vimrc is `filetype on`. This\nsimply means that `filetype.vim` is read at startup which sets autocmds for\nalmost all filetypes under the sun.\n\nIf you're brave enough, have a look at it: `:e $VIMRUNTIME/filetype.vim`. Search\nfor \"Ruby\" and you'll find that Vim simply uses the file extension `.rb` to\ndetect Ruby files:\n\n**NOTE**: Autocmds of the same event are executed in the order they were\ncreated. `:au` shows them in the correct order.\n\n```vim\nau BufNewFile,BufRead *.rb,*.rbw  setf ruby\n```\n\nThe `BufNewFile` and `BufRead` events in this case are hardcoded in the C\nsources of Vim and get emitted every time you open a file via `:e` and similar\ncommands. Afterwards all the hundreds of filetypes from `filetype.vim` are\ntested for.\n\nPutting it in a nutshell, Vim makes heavy use of events and autocmds but also\nexposes a clean interface to hook into that event-driven system for\ncustomization.\n\nHelp: `:h autocommand`\n\n## Changelist, jumplist\n\nThe positions of the last 100 changes are kept in the **changelist**. Several\nsmall changes on the same line will be merged together, but the position will be\nthat of the last change nevertheless (in case you added something in the middle\nof the line).\n\nEvery time you jump, the position _before_ the jump is remembered in the\n**jumplist**. A jumplist has up to 100 entries. Each window has its own\njumplist. When you split a window, the jumplist is copied.\n\nA jump is one of the following commands: `'`, `` ` ``, `G`, `/`, `?`, `n`, `N`,\n`%`, `(`, `)`, `[[`, `]]`, `{`, `}`, `:s`, `:tag`, `L`, `M`, `H` and commands\nthat start editing a new file.\n\n| List       | List all entries | Go to older position | Go to newer position |\n|------------|------------------|----------------------|----------------------|\n| jumplist   | `:jumps`         | `[count]<c-o>`       | `[count]<c-i>`       |\n| changelist | `:changes`       | `[count]g;`          | `[count]g,`          |\n\nWhen you list all entries, a marker `>` will be used to show the current\nposition. Usually that will be below position 1, the latest position.\n\nIf you want both lists to persist after restarting Vim, you need to use the\nviminfo file and `:h viminfo-'`.\n\n**NOTE**: The position before the latest jump is also kept as a [mark](#marks)\nand can be jumped to via ``` `` ``` or `''`.\n\nHelp:\n\n```\n:h changelist\n:h jumplist\n```\n\n## Undo tree\n\nThe latest changes to the text state are remembered. You can use _undo_ to\nrevert changes and _redo_ to reapply previously reverted changes.\n\nThe important bit to understand it that the data structure holding recent\nchanges is not a\n[queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) but a\n[tree](https://en.wikipedia.org/wiki/Tree_(data_structure))! Your changes are\nnodes in the tree and each (but the top node) has a parent node. Each node keeps\ninformation about the changed text and time. A branch is a series of nodes that\nstarts from any node and goes up to the top node. New branches get created when\nyou undo a change and then insert something else.\n\n```\nifoo<esc>\nobar<esc>\nobaz<esc>\nu\noquux<esc>\n```\n\nNow you have 3 lines and the undo tree looks like this:\n\n```\n     foo(1)\n       /\n    bar(2)\n   /      \\\nbaz(3)   quux(4)\n```\n\nThe undo tree has 4 changes. The numbers represent the _time_ the nodes were\ncreated.\n\nNow there are two ways to traverse this tree, let's call them _branch-wise_ and\n_time-wise_.\n\nUndo (`u`) and redo (`<c-r>`) work branch-wise. They go up and down the current\nbranch. `u` will revert the text state to the one of node \"bar\". Another `u`\nwill revert the text state even further, to the one of node \"foo\". Now `<c-r>`\ngoes back to the state of node \"bar\" and another `<c-r>` to the state of node\n\"quux\". (There's no way to reach node \"baz\" using branch-wise commands anymore.)\n\nOpposed to this, `g-` and `g+` work time-wise. Thus, `g-` won't revert to the\nstate of node \"bar\", like `u` does, but to the chronologically previous state,\nnode \"baz\". Another `g-` would revert the state to the one of node \"bar\" and so\non. Thus, `g-` and `g+` simply go back and forth in time, respectively.\n\n| Command / Mapping | Action |\n|-------------------|--------|\n| `[count]u`, `:undo [count]` | Undo [count] changes. |\n| `[count]<c-r>`, `:redo` | Redo [count] changes. |\n| `U` | Undo all changes to the line of the latest change. |\n| `[count]g-`, `:earlier [count]?` | Go to older text state [count] times. The \"?\" can be either \"s\", \"m\", \"h\", \"d\", or \"f\". E.g. `:earlier 2d` goes to the text state from 2 days ago. `:earlier 1f` will go to the state of the latest file save. |\n| `[count]g+`, `:later [count]?` | Same as above, but other direction. |\n\nThe undo tree is kept in memory and will be lost when Vim quits. See [Undo\nfiles](#undo-files) for how to enable persistent undo.\n\nIf you're confused by the undo tree,\n[undotree](https://github.com/mbbill/undotree) does a great job at visualizing\nit.\n\nHelp:\n\n```\n:h undo.txt\n:h usr_32\n```\n\n## Quickfix and location lists\n\nThe quickfix list is a data structure that holds file positions. Essentially,\neach entry in the quickfix list consists of a file path, a line number and\noptional column, and a description.\n\nTypical use cases are assembling compiler errors or results of a grep tool.\n\nVim has a special type of buffer for showing the quickfix list: the quickfix\nbuffer. Each line in the quickfix buffer shows one entry from the quickfix list.\n\nUsually you open a new window to display the quickfix list: the quickfix window.\nWhen that happens, the last window gets associated with the quickfix window.\n\nIn the quickfix buffer `<cr>` opens the selected entry in the associated window\nand `<c-w><cr>` in a new window.\n\nThe quickfix list was named after the \"quick fix\" feature from the [Aztec C\ncompiler](https://en.wikipedia.org/wiki/Aztec_C).\n\nActually there are two kinds of lists: quickfix and location lists. They behave\nalmost the same, but have the follwing differences:\n\n- There is only one quickfix list. There can be multiple location lists; one per\n  window.\n- They use slightly different commands for navigation.\n\n| Action         | Quickfix     | Location     |\n|----------------|--------------|--------------|\n| open window    | `:copen`     | `:lopen`     |\n| close window   | `:cclose`    | `:lclose`    |\n| next entry     | `:cnext`     | `:lnext`     |\n| previous entry | `:cprevious` | `:lprevious` |\n| first entry    | `:cfirst`    | `:lfirst`    |\n| last entry     | `:clast`     | `:llast`     |\n\nMind that the quickfix and location windows don't need to be open for these\ncommands to work.\n\nSee `:h quickfix` for more information and a full list of commands.\n\nFor conciseness, _quickfix_ and _location_ are often abbreviated as _qf_ and\n_loc_ respectively.\n\n**Example**:\n\nLet us use our good old friend `grep` for searching the files in the current\ndirectory recursively for a certain query and put the results in the quickfix\nlist.\n\n```vim\n:let &grepprg = 'grep -Rn $* .'\n:grep! foo\n<grep output - hit enter>\n:copen\n```\n\nAssuming any files contained the string \"foo\", it should be shown now in the\nquickfix window.\n\n## Macros\n\nVim allows _recording_ typed characters into a [register](#registers). It's a\ngreat way to automate certain tasks on the fly. (For more elaborate tasks, Vim\nscripting should be used instead.)\n\n- Start recording by typing `q` followed by the register, e.g. `q`. (The\n  command-line will signify this via \"recording @q\".)\n- Stop recording by hitting `q` once again.\n- Execute the macro via `[count]@q`.\n- Repeat the last used macro via `[count]@@`.\n\n**Example 1:**\n\nInsert a line and repeat it 10 times:\n\n```\nqq\niabc<cr><esc>\nq\n10@q\n```\n\n(The same could be done without macros: `oabc<esc>10.`)\n\n**Example 2:**\n\nFor adding line numbers in front of all lines, start on the first line and add\n\"1. \" to it manually. Increment the number under the cursor by using `<c-a>`,\ndisplayed as `^A`.\n\n```\nqq\n0yf jP0^A\nq\n1000@q\n```\n\nHere we simply hope that the file doesn't contain more than 1000 lines when\nusing `1000@q`, but we can also use a _recursive macro_, which executes until\nthe macro can't be applied to a line anymore:\n\n```\nqq\n0yf jP0^A@q\nq\n@q\n```\n\n(The same could be done without macros: `:%s/^/\\=line('.') . '. '`)\n\nMind that I also show how to achieve the same without using macros, but this\nmostly works only for such simple examples. For more complex automation, macros\nare the bomb!\n\nAlso see: [Quickly edit your macros](#quickly-edit-your-macros)\n\nHelp:\n\n```\n:h recording\n:h 'lazyredraw'\n```\n\n## Colorschemes\n\nColorschemes are the way to style your Vim. Vim consists of many components and\neach of those can be customized with different colors for the foreground,\nbackground and a few other attributes like bold text etc. They can be set like\nthis:\n\n```vim\n:highlight Normal ctermbg=1 guibg=red\n```\n\nThis would paint the background of the editor red. See `:h :highlight` for more\ninformation.\n\nSo, colorschemes are mostly collections of `:highlight` commands.\n\nActually, most colorschemes are really 2 colorschemes! The example above sets\ncolors via `ctermbg` and `guibg`. The former definition (`cterm*`) will only be\nused if Vim was started in a terminal emulator, e.g. xterm. The latter (`gui*`)\nwill be used in graphical environments like gvim or MacVim.\n\nIf you ever happen to use a colorscheme in terminal Vim and the colors don't\nlook like the ones in the screenshot at all, chances are that the colorscheme\nonly defines colors for the GUI. Conversely, if you use a graphical Vim (e.g.\ngvim or MacVim) and the colors look off, the colorscheme might only define\ncolors for the terminal.\n\nThe latter case can be \"solved\" by enabling true colors in Neovim or Vim\n7.4.1830 and newer. This makes terminal Vim use the GUI definitions instead, but\nalso requires the terminal emulator itself and all software in between (e.g.\ntmux) to be capable of handling true colors. ([This\ngist](https://gist.github.com/XVilka/8346728) gives a good overview about the\ntopic.)\n\nHelp:\n\n- `:h 'termguicolors'`\n- [List of colorschemes](PLUGINS.md#colorschemes-1)\n- [Cosmetic changes to colorschemes](#cosmetic-changes-to-colorschemes)\n\n## Folding\n\nEvery text (or source code) has a certain structure. If you have a structure, it\nmeans you have regions of logically separated text. Folding allows to \"fold\"\nsuch a region into a single line and displaying a short description. There are\nmany commands that act on these regions called _folds_. Folds can be nested.\n\nVim distinguishes between several types of fold methods:\n\n| 'foldmethod' | Usage |\n|--------------|-------|\n| diff         | Used in diff windows to fold unchanged text. |\n| expr         | Uses `'foldexpr'` to basically create a new fold method. |\n| indent       | Folds based on indentation. |\n| manual       | Create folds yourself via `zf`, `zF`, and `:fold`. |\n| marker       | Folds based on markers in the text (often in comments). |\n| syntax       | Folds based on syntax, e.g. folding `if` blocks. |\n\n**NOTE**: Folding can be computationally intensive! If you experience any\nperformance drawbacks (small delays when typing), have a look at\n[FastFold](https://github.com/Konfekt/FastFold), which prevents Vim from\nupdating folds when it's not needed.\n\nHelp:\n\n```\n:h usr_28\n:h folds\n```\n\n## Sessions\n\nIf you save a **view** (`:h :mkview`), the current state of the window (and\noptions and mappings) gets saved for later use (`:h :loadview`).\n\nA **session** saves the views of all windows plus global settings. It basically\nmakes a snapshot of your current Vim instance and saves it in a session file.\nLet me stress this: it saves the current state; everything done after saving a\nsession won't be part of the session file. To \"update\" a session, simply write\nit out again.\n\nThis makes it perfect for saving your _projects_ and easy to switch between\nthem.\n\nTry it right now! Open a few windows and tabs and do `:mksession Foo.vim`. If\nyou omit the filename, `Session.vim` will be assumed. The file will be saved to\nthe current working directory, check `:pwd`. Restart Vim and do `:source\nFoo.vim` and voil\u00e0, the buffer list, window layout, mappings, working directory\netc. should all be the same as before you saved the session. Do some more work\nand update the session by overwriting the already existing session file with\n`:mksession! Foo.vim`.\n\nNote that a session file is really just a collection of Vim commands that are\nsupposed to restore a certain state of a Vim instance, so feel free to take a\nlook at it: `:vs Foo.vim`.\n\nYou can tell Vim what things to save in a session by setting `'sessionoptions'`.\n\nFor scripting purposes Vim keeps the name of the last sourced or written session\nin the internal variable `v:this_session`.\n\nHelp:\n\n```\n:h Session\n:h 'sessionoptions'\n:h v:this_session\n```\n\n## Locality\n\nMany of the concepts mentioned above also have _local_ counterparts:\n\n| Global | Local | Scope | Help |\n|--------|-------|-------|------|\n| `:set`     | `:setlocal`           | buffer or window | `:h local-options`    |\n| `:map`     | `:map <buffer>`       | buffer           | `:h :map-local`       |\n| `:autocmd` | `:autocmd * <buffer>` | buffer           | `:h autocmd-buflocal` |\n| `:cd`      | `:lcd`                | window           | `:h :lcd`             |\n| `<leader>` | `<localleader>`       | buffer           | `:h maplocalleader`   |\n\n[Variables also have different scopes](https://vimhelp.appspot.com/usr_41.txt.html#41.2).\n\n# Usage\n\n## Getting help offline\n\nVim comes with great documentation in the form of single text files with a\nspecial layout. Vim uses a system based on tags for accessing certain parts of\nthose help files.\n\nFirst of all, read this: `:help :help`. This will open the file\n`$VIMRUNTIME/doc/helphelp.txt` in a new window and jump to the `:help` tag\nwithin that file.\n\nA few simple rules:\n\n- options are enclosed in single quotes, e.g. `:h 'textwidth'`\n- VimL functions end in `()`, e.g. `:h reverse()`\n- commands start with `:`, e.g. `:h :echo`\n\nYou can use `<c-d>` (this is <kbd>ctrl</kbd>+<kbd>d</kbd>) to list all tags that\nmatch the currently entered query. E.g. `:h tab<c-d>` will get you a list of all\ntags from `tab` over `'softtabstop'` to `setting-guitablabel`.\n\nYou want to list all VimL functions? Simple: `:h ()<c-d>`. You want to list all\nVimL functions that concern windows? `:h win*()<c-d>`.\n\nThis quickly becomes second nature, but especially in the beginning, you\nsometimes don't know any part of the tag you are looking for. You can only\nimagine some keywords that could be involved. `:helpgrep` to the rescue!\n\n```\n:helpgrep backwards\n```\n\nThis will look for \"backwards\" in all documentation files and jump to the first\nmatch. The matches will be assembled in the quickfix list. Use `:cn`/`:cp` to\njump to the next/previous match. Or use `:copen` to open the quickfix window,\nnavigate to an entry and hit `<cr>` to jump to that match. See `:h quickfix` for\nthe whole truth.\n\n## Getting help offline (alternative)\n\nThis list was compiled by @chrisbra, one of the most active Vim developers, and\nposted to [vim_dev](https://groups.google.com/forum/#!forum/vim_dev).\n\nIt's reposted here with minor changes.\n\n---\n\nIf you know what you are looking for, it is usually easier to search for it\nusing the help system, because the subjects follow a certain style guide.\n\nAlso, the help has the advantage of belonging to your particular Vim version, so\nthat obsolete topics or topics that have been added later won't turn up.\n\nTherefore, it is essential to learn the help system and the language it uses.\nHere are some examples (not necessarily complete and I might have forgotten\nsomething).\n\n1. Options are enclosed in single quotes. So you would use `:h 'list'` to go to\n   the help topic for the list option. If you only know, you are looking for a\n   certain option, you can also do `:h options.txt` to open the help page which\n   describes all option handling and then you can search using regular\n   expressions e.g. `/width`. Certain options have their own namespace, e.g. `:h\n   cpo-a`, `:h cpo-A`, `:h cpo-b`, and so on.\n\n2. Normal mode commands are just that. Use `:h gt` to go to the help page for\n   the \"gt\" command.\n\n3. Regexp items always start with \"/\", so `:h /\\+` takes you to the help item\n   for the \"\\+\" quantifier in Vim regexes. If you need to know anything about\n   regular expressions, start reading at `:h pattern.txt`.\n\n4. Key combinations. They usually start with a single letter indicating the mode\n   for which they can be used. E.g. `:h i_CTRL-X` takes you to the family of\n   CTRL-X commands for insert mode which can be used to auto complete different\n   things. Note that certain keys will always be written the same, e.g. Control\n   will always be CTRL. Note, for normal mode commands, the \"n\" is left away,\n   e.g. `:h CTRL-A`. In contrast, `:h c_CTRL-R` will describe what CTRL-R does\n   when entering commands in the command line and `:h v_Ctrl-A` talks about\n   incrementing numbers in visual mode and `:h g_CTRL-A` talks about the g<C-A>\n   command (thus you have to press \"g\" then <Ctrl-A>). Here the \"g\" stand for\n   the normal command \"g\" which always expect a second key before doing\n   something similar to the commands starting with \"z\".\n\n5. Registers always start with \"quote\" so use `:h quote` to find out about the\n   special \":\" register.\n\n6. Vim script (VimL) is available at `:h eval.txt`. Certain aspects of the\n   language are available at `:h expr-X` where 'X' is a single letter, e.g. `:h\n   expr-!` will take you to the topic describing the '!' (Not) operator for\n   VimL. Also important, see `:h function-list` to find a short description of\n   all functions available.\n\n7. Mappings are talked about in the help page `:h map.txt`. Use `:h mapmode-i`\n   to find out about the `:imap` command. Also use `:map-topic` to find out\n   about certain subtopics particular for mappings (e.g. `:h :map-local` for\n   buffer-local mappings or `:h map_bar` for how the '|' is handled in mappings.\n\n8. Command definitions are talked about at `:h command-*`, so use :h command-bar\n   to find out about the '!' argument for custom commands.\n\n9. Window management commands always start with CTRL-W, so you find the\n   corresponding help at `:h CTRL-W_*` (e.g. `:h CTRL-W_p` for switch to the\n   previously accessed window). You can also access `:h windows.txt` and read\n   your way through, if you are looking for window handling command.\n\n10. Ex commands always start with \":\", so `:h :s` covers the \":s\" command.\n\n11. Use CTRL-D after typing a topic and let Vim try to complete to all available\n    topics.\n\n12. Use `:helpgrep` to search in all help pages (usually also includes help\n    pages by installed plugins). See `:h :helpgrep` for how to use it. Once you\n    have searched for a topic, all matches are available in the quickfix (or\n    location) window which can be opened with `:copen` or `:lopen`. There you\n    can also use `/` to further filter the matches.\n\n13. `:h helphelp` contains some information on how to use the help.\n\n14. The user manual. This describes help topics for beginners in a rather\n    friendly way. Start at `:h usr_toc.txt` to find the table of content (as you\n    might have guessed). Skimming over that help to find certain topics, .e.g\n    you will find an entry \"Digraphs\" and \"Entering special characters\" in\n    chapter 24 (so use `:h usr_24.txt` to go to that particular help page).\n\n15. Highlighting groups always start with `hl-*`. E.g. `:h hl-WarningMsg` talks\n    about the \"WarningMsg\" highlighting group.\n\n16. Syntax highlighting is namespaced to \":syn-topic\", e.g. `:h :syn-conceal`\n    talks about the conceal argument for the :syn command.\n\n17. Quickfix commands usually start with \":c\", while location list commands\n    usually start with \":l\".\n\n18. `:h BufWinLeave` talks about the BufWinLeave autocmd. Also, `:h\n    autocommands-events` talks about all possible events.\n\n19. Startup arguments always start with \"-\", so `:h -f` takes you to the help of\n    the \"-f\" command switch of Vim.\n\n20. Compiled extra features always start with \"+\", so `:h +conceal` talks about\n    the conceal support.\n\n21. Error codes can be looked up directly in the help. `:h E297` takes you\n    exactly to the description of the error message. Sometimes however, those\n    error codes are not described, but rather are listed at the Vim command that\n    usually causes this. E.g. `:h hE128` takes you directly to the `:function`\n    command.\n\n22. Documentation for included syntax files is usually available at `:h\n    ft-*-syntax`. E.g. `:h ft-c-syntax` talks about the C syntax file and the\n    options it provides. Sometimes, additional sections for omni completion (`:h\n    ft-php-omni`) or filetype plugins (`:h ft-tex-plugin`) are available.\n\nAlso, a link to the user documentation (which describes certain commands more\nfrom a user perspective and less detailed) will be mentioned at the top of help\npages if they are available. So `:h pattern.txt` mentions the user guide topics\n`:h 03.9` and `:h usr_27`.\n\n## Getting help online\n\nIf you have an issue you can't resolve or are in need of general guidance, see\nthe [vim_use](https://groups.google.com/forum/#!forum/vim_use) mailing list.\nAnother great resource is using\n[IRC](https://de.wikipedia.org/wiki/Internet_Relay_Chat). The channel `#vim` on\n[Freenode](https://freenode.net) is huge and usually full of helpful people.\n\nIf you want to report a Vim bug, use the\n[vim_dev](https://groups.google.com/forum/#!forum/vim_dev) mailing list.\n\n## Autocmds in practice\n\nYou can trigger any event right now: `:doautocmd BufRead`.\n\n### User events\n\nEspecially for plugins it's useful to create your own \"User\" events:\n\n```vim\nfunction! Chibby()\n  \" A lot of stuff is happening here.\n  \" And at last..\n  doautocmd User ChibbyExit\nendfunction\n```\n\nNow users of your plugin can execute anything when Chibby finishes running:\n\n```vim\nautocmd User ChibbyExit call ChibbyCleanup()\n```\n\nBy the way, if there's no \"catching\" :autocmd, :doautocmd will output a pesky\n\"No matching autocommands\" message. That's why many plugins use `silent\ndoautocmd ...` instead. But this has the disadvantage, that you can't simply use\n`echo \"foo\"` in the :autocmd, you have to use `unsilent echo \"foo\"` instead..\n\nThat's why it's better to check if there even is a receiving autocmd and not\nbothering emitting the event otherwise:\n\n```vim\nif exists('#User#ChibbyExit')\n  doautocmd User ChibbyExit\nendif\n```\n\nHelp: `:h User`\n\n### Nested autocmds\n\nBy default, autocmds do not nest! If an autocmd executes a command, which in\nturn would usually trigger another event, it won't happen.\n\nLet's say every time you start Vim, you want to automatically open your vimrc:\n\n```vim\nautocmd VimEnter * edit $MYVIMRC\n```\n\nWhen you now start Vim, it will open your vimrc, but the first thing you'll\nnotice is that there won't be any highlighting although usually there would be.\n\nThe problem is that `:edit` in your non-nested autocmd won't trigger the\n\"BufRead\" event, so the filetype never gets set to \"vim\" and\n`$VIMRUNTIME/syntax/vim.vim` never sourced. See `:au BufRead *.vim`. Use this\ninstead:\n\n```vim\nautocmd VimEnter * nested edit $MYVIMRC\n```\n\nHelp: `:h autocmd-nested`\n\n## Clipboard\n\nRequired [features](#what-kind-of-vim-am-i-running): `+clipboard` and optionally\n`+xterm_clipboard` if you want to use the `'clipboard'` option on a Unix system\nwith a Vim that doesn't have GUI support.\n\nHelp:\n\n```\n:h 'clipboard'\n:h gui-clipboard\n:h gui-selections\n```\n\nAlso see: [Bracketed paste (or why do I have to set 'paste' all the\ntime?)](#bracketed-paste-or-why-do-i-have-to-set-paste-all-the-time)\n\n### Clipboard usage (Windows, macOS)\n\nWindows comes with a\n[clipboard](https://msdn.microsoft.com/en-us/library/windows/desktop/ms649012(v=vs.85).aspx)\nand macOS comes with a\n[pasteboard](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008100-SW1).\n\nBoth work like most users would expect them to work. You copy selected text with\n`ctrl+c`/`cmd+c` and paste them in another application with `ctrl+v`/`cmd+v`.\n\nNote that copied text is actually transferred to the clipboard, so you can close\nthe application you copied from before pasting in another application without\nproblems.\n\nWhenever this happens, the clipboard register `*` gets filled with the\nselection. From Vim use `\"*y` and `\"*p` to yank and paste from the clipboard\nrespectively.\n\nIf you don't even want to specify the `*` register all the time, put this in\nyour vimrc:\n\n```vim\nset clipboard=unnamed\n```\n\nUsually all yank/delete/put operations fill the `\"` register, now the `*`\nregister is used for the same operations, therefore simply `y` and `p` will be\nenough.\n\nLet me repeat: Using the option above means that every yank/paste, even when\nonly used in the same Vim window, will alter the clipboard. Decide for yourself\nif this is useful or not.\n\nIf you're even too lazy to type `y`, you can send every visual selection to the\nclipboard by using these settings:\n\n```vim\nset clipboard=unnamed,autoselect\nset guioptions+=a\n```\n\nHelp:\n\n```\n:h clipboard-unnamed\n:h autoselect\n:h 'go_a'\n```\n\n### Clipboard usage (Linux, BSD, ...)\n\nIf your OS uses [X](http://www.x.org/wiki), things work a bit different. X\nimplements the [X Window System\nProtocol](http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html) which\nhappens to be at major version 11 since 1987, hence X is also often called X11.\n\nPrior, in X10, [cut\nbuffers](http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Cut_Buffers)\nwere introduced that kind of worked like a _clipboard_ as in copied text was\nactually held by X and it was accessible by all other applications. This\nmechanism still exists in X, but its use is deprecated now and most software\ndoesn't use it anymore.\n\nNowadays data is transferred between applications by the means of\n[selections](http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Selections).\nFrom the 3 _selection atoms_ defined, only 2 are used in practice: PRIMARY and\nCLIPBOARD.\n\nSelections work roughly like this:\n\n```\nProgram A: <ctrl+c>\nProgram A: assert ownership of CLIPBOARD\nProgram B: <ctrl+v>\nProgram B: note that ownership of CLIPBOARD is hold by Program A\nProgram B: request data from Program A\nProgram A: respond to request and send data to Program B\nProgram B: receives data from Program A and inserts it into the window\n```\n\n| Selection | When used? | How to paste? | How to access from Vim? |\n|-----------|------------|---------------|-------------------------|\n| PRIMARY   | Selecting text              | `middle-click`, `shift+insert` | `*` register |\n| CLIPBOARD | Selecting text and `ctrl+c` | `ctrl+v`                       | `+` register |\n\n**NOTE**: Selections (no, not even the CLIPBOARD selection) are never kept in\nthe X server! Thus, you lose the data copied with `ctrl+c` when the application\ncloses.\n\nUse `\"*p` to paste the PRIMARY selection or `\"+y1G` to yank the entire file to\nthe CLIPBOARD selection.\n\nIf you happen to access one of the two registers all the time, consider using:\n\n```vim\nset clipboard^=unnamed      \" * register\n\" or\nset clipboard^=unnamedplus  \" + register\n```\n\n(The `^=` is used to prepend to the default value, `:h :set^=`.)\n\nThis will make all yank/delete/put operations use either `*` or `+` instead of\nthe unnamed register `\"`. Afterwards you can simply use `y` or `p` for accessing\nyour chosen X selection.\n\nHelp:\n\n```vim\n:h clipboard-unnamed\n:h clipboard-unnamedplus\n```\n\n## Restore cursor position when opening file\n\nWhen you open a file, the cursor will be positioned at line 1, column 1.\nFortunately the viminfo file remembers [marks](#marks). The `\"` mark contains\nthe position in the buffer where you left off.\n\n```vim\nautocmd BufReadPost *\n    \\ if line(\"'\\\"\") > 1 && line(\"'\\\"\") <= line(\"$\") |\n    \\   execute \"normal! g`\\\"\" |\n    \\ endif\n```\n\nRead: If the mark `\"` contains a line number greater than line 1 but not greater\nthan the last line in the file, jump to it.\n\n    :h viminfo-'\n    :h `quote\n    :h g`\n\n## Temporary files\n\n### Backup files\n\nBefore saving a file, Vim creates a backup file. If writing to disk was\nsuccessful, the backup file will be deleted.\n\nWith `:set backup`, the backup will persist. This means, the backup file will\nalways have the same content as the original file _before_ the most recent save.\nIt's up to you to decide whether this is useful or not.\n\nYou can disable backups entirely with `:set nobackup nowritebackup`, but you\nshouldn't need to nowadays. `'writebackup'` is a security feature that makes\nsure that you don't lose the original file in case saving it should ever fail,\nno matter whether you keep the backup file afterwards or not.\n\nIf you frequently use Vim to edit huge files, [and you probably\nshouldn't](#editing-huge-files-is-slow), you can exclude those from backups with\n`'backupskip'`.\n\nVim knows different ways to create a backup: _copying_ and _renaming_.\n\n- **Copying**\n    1. A full copy of the original file is created and used as backup.\n    1. The original file gets emptied and then filled with the content of the\n    Vim buffer.\n- **Renaming**\n    1. The original file is renamed to the backup file.\n    1. The content of the Vim buffer gets written to a new file with the name of\n    the original file.\n\nSee `:h 'backupcopy'` for all the nitty-gritty details.\n\n---\n\nDemo:\n\n```vim\n:set backup backupskip= backupdir=. backupext=-backup\n:e /tmp/foo\nifoo<esc>\n:w\n\" original file gets created, no need for backup file\nobar<esc>\n:w\n\" backup file is created, original file gets updated\n```\n\n```diff\n$ diff -u /tmp/foo-backup /tmp/foo\n--- /tmp/foo-backup     2017-04-22 15:05:13.000000000 +0200\n+++ /tmp/foo    2017-04-22 15:05:25.000000000 +0200\n@@ -1 +1,2 @@\n foo\n+bar\n```\n\n---\n\n    :h backup\n    :h write-fail\n\n### Swap files\n\nWhen editing a file, unsaved changes get written to a swap file.\n\nGet the name of the current swap file with `:swapname`. Disable them with `:set\nnoswapfile`.\n\nA swap file gets updated either all 200 characters or when nothing was typed for\n4 seconds. They get deleted when you stop editing the file. You can change these\nnumbers with `:h 'updatecount'` and `:h 'updatetime'`.\n\nIf Vim gets killed (e.g. power outage), you lose all changes since the last time\nthe file was written to disk, but the swap file won't be deleted. Now, if you\nedit the file again, Vim will offer the chance to recover the file from the swap\nfile.\n\nWhen two people try to edit the same file, the second person will get a notice\nthat the swap file already exists. It prevents people from trying to save\ndifferent versions of a file. If you don't want that behaviour, see `:h\n'directory'`.\n\n    :h swap-file\n    :h usr_11\n\n### Undo files\n\nThe [undo tree](#undo-tree) is kept in memory and will be lost when Vim quits.\nIf you want it to persist, `:set undofile`. This will save the undo file for\n`~/foo.c` in `~/foo.c.un~`.\n\n    :h 'undofile'\n    :h undo-persistence\n\n### Viminfo files\n\nWhen backup, swap, and undo files are all about text state, viminfo files are\nused for saving everything else that would otherwise be lost when quitting Vim.\nThe viminfo file keeps histories (command line, search, input), registers,\nmarks, buffer list, global variables etc.\n\nBy default, the viminfo is written to `~/.viminfo`.\n\n    :h viminfo\n    :h 'viminfo'\n\n### Example configuration for temporary files\n\nPut all temporary files in their own directory under `~/.vim/files`:\n\n```vim\n\" create directory if needed\nif !isdirectory($HOME.'/.vim/files') && exists('*mkdir')\n  call mkdir($HOME.'/.vim/files')\nendif\n\n\" backup files\nset backup\nset backupdir   =$HOME/.vim/files/backup/\nset backupext   =-vimbackup\nset backupskip  =\n\" swap files\nset directory   =$HOME/.vim/files/swap//\nset updatecount =100\n\" undo files\nset undofile\nset undodir     =$HOME/.vim/files/undo/\n\" viminfo files\nset viminfo     ='100,n$HOME/.vim/files/info/viminfo\n```\n\n## Editing remote files\n\nVim comes with the netrw plugin that enables editing remote files. Actually it\ntransfers the remote file to a local temporary file via scp, opens a buffer\nusing that file, and writes the changes back to the remote file on saving.\n\nThis is extremely useful if you want to use your local configuration opposed to\nssh'ing into a server and use whatever the admins want you to use.\n\n```\n:e scp://bram@awesome.site.com/.vimrc\n```\n\nIf you have a `~/.ssh/config` set up already, this gets used automatically:\n\n```\nHost awesome\n    HostName awesome.site.com\n    Port 1234\n    User bram\n```\n\nAssuming the above content in `~/.ssh/config`, this works just as well:\n\n```\n:e scp://awesome/.vimrc\n```\n\nSimilar can be done with a `~/.netrc`, see `:h netrw-netrc`.\n\nMake sure to read `:h netrw-ssh-hack` and `:h g:netrw_ssh_cmd`.\n\n---\n\nAnother possibility is using [sshfs](https://wiki.archlinux.org/index.php/Sshfs)\nwhich uses [FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) to\nmount a remote filesystem into your local filesystem.\n\n## Managing plugins\n\n[Pathogen](https://github.com/tpope/vim-pathogen) was the first popular tool for\nmanaging plugins. Actually it just adjusts the _runtimepath_ (`:h 'rtp'`) to\ninclude all the things put under a certain directory. You have to clone the\nrepositories of the plugins there yourself.\n\nReal plugin managers expose commands that help you to install and update plugins\nfrom within Vim.\n\n[List of plugin managers](PLUGINS.md#plugin-managers)\n\n## Block insert\n\nThis is a technique to insert the same text on multiple consecutive lines at the\nsame time. See this\n[demo](https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-block_insert.gif).\n\nSwitch to visual block mode with `<c-v>`. Afterwards go down for a few lines.\nHit `I` or `A` and start entering your text.\n\nIt might be a bit confusing at first, but text is always entered for the current\nline and only after finishing the current insertion, the same text will be\napplied to all other lines of the prior visual selection.\n\nSo a simple example is `<c-v>3jItext<esc>`.\n\nIf you have lines of different length and want to append the same text right\nafter the end of each line, do this: `<c-v>3j$Atext<esc>`.\n\nSometime you need to place the cursor somewhere after the end of the current\nline. You can't do that by default, but you can set the `virtualedit` option:\n\n```vim\nset virtualedit=all\n```\n\nAfterwards `$10l` or `90|` work even after the end of the line.\n\nSee `:h blockwise-examples` for more info. It might seem complicated at first,\nbut quickly becomes second nature.\n\nIf you want to get real fancy, have a look at\n[multiple-cursors](https://github.com/terryma/vim-multiple-cursors).\n\n## Running external programs and using filters\n\nDisclaimer: Vim is single-threaded, so running an external program in the\nforeground will block everything else. Sure, you can use one of Vim's\nprogramming interfaces, e.g. Lua, and use its thread support, but during that\ntime the Vim process is blocked nevertheless. Neovim fixed that by adding a\nproper job API.\n\n(Apparently Bram is thinking about adding job control to Vim as well. If you\nhave a very recent version, see `:helpgrep startjob`.)\n\nUse `:!` to start a job. If you want to list the files in the current working\ndirectory, use `:!ls`. Use `|` for piping in the shell as usual, e.g. `:!ls -1 |\nsort | tail -n5`.\n\nWithout a range, the output of `:!` will be shown in a scrollable window. On the\nother hand, if a range is given, these lines will be\n[filtered](https://en.wikipedia.org/wiki/Filter_(software)). This means they\nwill be piped to the\n[stdin](https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29)\nof the filter program and after processing be replaced by the\n[stdout](https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29)\nof the filter. E.g. for prepending numbers to the next 5 lines, use this:\n\n    :.,+4!nl -ba -w1 -s' '\n\nSince manually adding the range is quite burdensome, Vim also provides some\nhelpers for convenience. As always with ranges, you can also select lines in\nvisual mode and then hit `:`. There's also an operator `!` that takes a motion.\nE.g. `!ip!sort` will sort the lines of the current paragraph.\n\nA good use case for filtering is the [Go programming\nlanguage](https://golang.org). The indentation is pretty opinionated, it even\ncomes with a filter called `gofmt` for indenting Go source code properly. So\nplugins for Go often provide helper commands called `:Fmt` that basically do\n`:%!gofmt`, so they indent all lines in the file.\n\nPeople often use `:r !prog` to put the output of prog below the current line,\nwhich is fine for scripts, but when doing it on the fly, I find it easier to use\n`!!ls` instead, which replaces the current line.\n\n    :h filter\n    :h :read!\n\n## Cscope\n\n[Cscope](http://cscope.sourceforge.net/) does more things than\n[ctags](http://ctags.sourceforge.net/), but only supports C (and C++ and Java to\nsome extent).\n\nWhereas a tags file only knows where a symbol was defined, a cscope database\nknows much more about your data:\n\n- Where is this symbol defined?\n- Where is this symbol used?\n- What is this global symbol's definition?\n- Where did this variable get its value?\n- Where is this function in the source files?\n- What functions call this function?\n- What functions are called by this function?\n- Where does the message \"out of space\" come from?\n- Where is this source file in the directory structure?\n- What files include this header file?\n\n### 1. Build the database\n\nDo this in the root of your project:\n\n```sh\n$ cscope -bqR\n```\n\nThis will create 3 files: `cscope{,.in,.po}.out` in the current working\ndirectory. Think of them as your database.\n\nUnfortunately `cscope` only analyzes `*.[c|h|y|l]` files by default. If you want\nto use cscope for a Java project instead, do this:\n\n```sh\n$ find . -name \"*.java\" > cscope.files\n$ cscope -bq\n```\n\n### 2. Add the database\n\nOpen a connection to your freshly built database:\n\n```vim\n:cs add cscope.out\n```\n\nVerify that the connection was made:\n\n```vim\n:cs show\n```\n\n(Yes, you can add multiple connections.)\n\n### 3. Query the database\n\n```vim\n:cs find <kind> <query>\n```\n\nE.g. `:cs find d foo` will list all functions that are called by `foo(...)`.\n\n| Kind | Explanation |\n|------|-------------|\n| s    | **s**ymbol: find all references to the token        |\n| g    | **g**lobal: find global definition(s) of the token  |\n| c    | **c**alls: find all calls to the function           |\n| t    | **t**ext: find all instances of the text            |\n| e    | **e**grep: egrep search for the word                |\n| f    | **f**ile: open the filename                         |\n| i    | **i**ncludes: find files that include the filename  |\n| d    | **d**epends: find functions called by this function |\n\nI suggest some convenience mappings e.g.:\n\n```vim\nnnoremap <buffer> <leader>cs :cscope find s  <c-r>=expand('<cword>')<cr><cr>\nnnoremap <buffer> <leader>cg :cscope find g  <c-r>=expand('<cword>')<cr><cr>\nnnoremap <buffer> <leader>cc :cscope find c  <c-r>=expand('<cword>')<cr><cr>\nnnoremap <buffer> <leader>ct :cscope find t  <c-r>=expand('<cword>')<cr><cr>\nnnoremap <buffer> <leader>ce :cscope find e  <c-r>=expand('<cword>')<cr><cr>\nnnoremap <buffer> <leader>cf :cscope find f  <c-r>=expand('<cfile>')<cr><cr>\nnnoremap <buffer> <leader>ci :cscope find i ^<c-r>=expand('<cfile>')<cr>$<cr>\nnnoremap <buffer> <leader>cd :cscope find d  <c-r>=expand('<cword>')<cr><cr>\n```\n\nSo, when `:tag` (or `<c-]>`) jumps to a definition from the tags file, `:cstag`\ndoes the same, but also takes connected cscope databases into account. The\noption `'cscopetag'` makes `:tag` act like `:cstag` automatically. This is very\nconvenient if you already have tag-related mappings.\n\nHelp: `:h cscope`\n\n## MatchIt\n\nSince Vim is written in C, a lot of features assume C-like syntax. By default,\nif your cursor is on `{` or `#endif`, you can use `%` to jump to the\ncorresponding `}` or `#ifdef` respectively.\n\nVim comes bundled with a plugin called matchit.vim which is not enabled by\ndefault. It makes `%` also cycle through HTML tags, if/else/endif constructs in\nVimL etc. and introduces a few new commands.\n\n#### Installation for Vim 8\n\n```vim\n\" vimrc\npackadd! matchit\n```\n\n#### Installation for Vim 7 and older\n\n```vim\n\" vimrc\nruntime macros/matchit.vim\n```\n\nSince the documentation of matchit is pretty extensive, I suggest also doing the\nfollowing once:\n\n```vim\n:!mkdir -p ~/.vim/doc\n:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc\n:helptags ~/.vim/doc\n```\n\n#### Small intro\n\nThe plugin is ready to use now. See `:h matchit-intro` for the supported\ncommands and `:h matchit-languages` for the supported languages.\n\nThat said, it's easy to define your own matching pairs:\n\n```vim\nautocmd FileType python let b:match_words = '\\<if\\>:\\<elif\\>:\\<else\\>'\n```\n\nAfterwards you can cycle through these 3 statements in any Python file by using\n`%` (forward) or `g%` (backward).\n\nHelp:\n\n```\n:h matchit-install\n:h matchit\n:h b:match_words\n```\n\n## True colors\n\nUsing true colors in a terminal emulator means being able to use 24 bits for RGB\ncolors. That makes 16777216 (2^24) colors instead of the usual 256.\n\nAs explained [here](#colorschemes), colorschemes can actually be _two_\ncolorschemes by having definitions for terminals (xterm) and for GUIs (gvim).\nThis made sense before terminal emulators learned about true colors.\n\nAfter `:set termguicolors`, Vim starts emitting escape sequences only understood\nby a terminal emulator that supports true colors. When your colors look weird,\nchances are your terminal emulator doesn't support true colors or your\ncolorcheme has no GUI colors defined.\n\nMany people use the terminal multiplexer\n[tmux](https://github.com/tmux/tmux/wiki) which basically sits in between the\nterminal emulator and Vim. To make tmux _forward_ the true color escape\nsequences emitted by Vim, you have to put the following in the user's\n`.tmux.conf`:\n\n```\nset-option -g  default-terminal 'tmux-256color'\nset-option -ga terminal-overrides ',xterm-256color:Tc'\n```\n\n- The first line should be the same for most people and denotes the `$TERM` to\n  be used _within_ tmux.\n- The second line adds the tmux-specific `Tc` (true color) capability to the\n  other terminfo entries of `xterm-256color`. Obviously this assumes that the\n  user is using `TERM=xterm-256color` _outside_ of tmux.\n\nSo, here is the checklist for enabling true colors:\n\n- Read `:h 'termguicolors'`.\n- Put `set termguicolors` in your vimrc.\n- Make sure your colorscheme has color definitions for GUIs. (It should contain\n  lines with `guifg` and `guibg`.)\n- Make sure your terminal emulator of choice supports true colors.\n- Using tmux? Configure it to add the `Tc` capability.\n\nA popular reference for colors in the terminal:\nhttps://gist.github.com/XVilka/8346728\n\n# Tips\n\n## Go to other end of selected text\n\n`o` and `O` in a visual selection make the cursor go to the other end. Try with\nblockwise selection to see the difference. This is useful for quickly changing\nthe size of the selected text.\n\n```\n:h v_o\n:h v_O\n```\n\n## Saner behavior of n and N\n\nThe direction of `n` and `N` depends on whether `/` or `?` was used for\nsearching forward or backward respectively. This is pretty confusing to me.\n\nIf you want `n` to always search forward and `N` backward, use this:\n\n```vim\nnnoremap <expr> n  'Nn'[v:searchforward]\nxnoremap <expr> n  'Nn'[v:searchforward]\nonoremap <expr> n  'Nn'[v:searchforward]\n\nnnoremap <expr> N  'nN'[v:searchforward]\nxnoremap <expr> N  'nN'[v:searchforward]\nonoremap <expr> N  'nN'[v:searchforward]\n```\n\n## Saner command-line history\n\nIf you're anything like me, you're used to going to next and previous items via\n`<c-n>` and `<c-p>` respectively. By default, this also works in the\ncommand-line and recalls older or more recent command-lines from history.\n\nSo far, so good. But `<up>` and `<down>` are even smarter! They recall the\ncommand-line whose beginning matches the current command-line. E.g. `:echo <up>`\nmay change to `:echo \"Vim rocks!\"`.\n\nOf course, I don't want you to reach for the arrow keys:\n\n```vim\ncnoremap <expr> <c-n> wildmenumode() ? \"\\<c-n>\" : \"\\<down>\"\ncnoremap <expr> <c-p> wildmenumode() ? \"\\<c-p>\" : \"\\<up>\"\n```\n\nHere we also distinguish between command-line history and the wildmenu. See `:h\n'wildmenu'`.\n\nI depend on this behaviour several times a day.\n\n## Saner CTRL-L\n\nBy default, `<c-l>` clears and redraws the screen (like `:redraw!`). The\nfollowing mapping does the same, plus de-highlighting the matches found via `/`,\n`?` etc., plus fixing syntax highlighting (sometimes Vim loses highlighting due\nto complex highlighting rules), plus force updating the syntax highlighting in\ndiff mode:\n\n```vim\nnnoremap <leader>l :nohlsearch<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>\n```\n\n## Disable audible and visual bells\n\n```vim\nset noerrorbells\nset novisualbell\nset t_vb=\n```\n\nSee [Vim Wiki: Disable beeping](http://vim.wikia.com/wiki/Disable_beeping).\n\n## Quickly move current line\n\nSometimes I need a quick way to move the current line above or below:\n\n```vim\nnnoremap [e  :<c-u>execute 'move -1-'. v:count1<cr>\nnnoremap ]e  :<c-u>execute 'move +'. v:count1<cr>\n```\n\nThese mappings also take a count, so `2]e` moves the current line 2 lines below.\n\n## Quickly add empty lines\n\n```vim\nnnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[\nnnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>\n```\n\nNow `5[<space>` inserts 5 blank lines above the current line.\n\n## Quickly edit your macros\n\nThis is a real gem! The mapping takes a register (or `*` by default) and opens\nit in the cmdline-window. Hit `<cr>` when you're done editing for setting the\nregister.\n\nI often use this to correct typos I did while recording a macro.\n\n```vim\nnnoremap <leader>m  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>\n```\n\nUse it like this `<leader>m` or `\"q<leader>m`.\n\nNotice the use of `<c-r><c-r>` to make sure that the `<c-r>` is inserted\nliterally. See `:h c_^R^R`.\n\n## Quickly jump to header or source file\n\nThis technique can probably be applied to many filetypes. It sets _file marks_\n(see `:h marks`) when leaving a source or header file, so you can quickly jump\nback to the last accessed one by using `'C` or `'H` (see `:h 'A`).\n\n```vim\nautocmd BufLeave *.{c,cpp} mark C\nautocmd BufLeave *.h       mark H\n```\n\n**NOTE**: The info is saved in the viminfo file, so make sure that `:set\nviminfo?` includes `:h viminfo-'`.\n\n## Quickly change font size in GUI\n\nI think this was taken from tpope's config:\n\n```vim\ncommand! Bigger  :let &guifont = substitute(&guifont, '\\d\\+$', '\\=submatch(0)+1', '')\ncommand! Smaller :let &guifont = substitute(&guifont, '\\d\\+$', '\\=submatch(0)-1', '')\n```\n\n## Change cursor style dependent on mode\n\nI like to use a block cursor in normal mode, i-beam cursor in insert mode, and\nunderline cursor in replace mode.\n\n```vim\nif empty($TMUX)\n  let &t_SI = \"\\<Esc>]50;CursorShape=1\\x7\"\n  let &t_EI = \"\\<Esc>]50;CursorShape=0\\x7\"\n  let &t_SR = \"\\<Esc>]50;CursorShape=2\\x7\"\nelse\n  let &t_SI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=1\\x7\\<Esc>\\\\\"\n  let &t_EI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=0\\x7\\<Esc>\\\\\"\n  let &t_SR = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=2\\x7\\<Esc>\\\\\"\nendif\n```\n\nThis simply tells Vim to print a certain sequence of characters ([escape\nsequence](https://en.wikipedia.org/wiki/Escape_sequence)) when entering/leaving\ninsert mode. The underlying terminal, or programs like\n[tmux](https://tmux.github.io) that sit between Vim and the terminal, will\nprocess and evaluate it.\n\nThere's one drawback though: there are many terminal emulator implementations\nand not all use the same sequences for doing the same things. The sequences used\nabove might not work with your implementation. Your implementation might not\neven support different cursor styles. Check the documentation.\n\nThe example above works with iTerm2.\n\n## Don't lose selection when shifting sidewards\n\nIf you select one or more lines, you can use `<` and `>` for shifting them\nsidewards. Unfortunately you immediately lose the selection afterwards.\n\nYou can use `gv` to reselect the last selection (see `:h gv`), thus you can work\naround it like this:\n\n```vim\nxnoremap <  <gv\nxnoremap >  >gv\n```\n\nNow you can use `>>>>>` on your visual selection without any problems.\n\n**NOTE**: The same can be achieved using `.`, which repeats the last change.\n\n## Reload a file on saving\n\nUsing [autocmds](#autocmds) you can do anything on saving a file, e.g. sourcing\nit in case of a dotfile or running a linter to check for syntactical errors in\nyour source code.\n\n```vim\nautocmd BufWritePost $MYVIMRC source $MYVIMRC\nautocmd BufWritePost ~/.Xdefaults call system('xrdb ~/.Xdefaults')\n```\n\n## Smarter cursorline\n\nI love the cursorline, but I only want to use it in the current window and not\nwhen being in insert mode:\n\n```vim\nautocmd InsertLeave,WinEnter * set cursorline\nautocmd InsertEnter,WinLeave * set nocursorline\n```\n\n## Faster keyword completion\n\nThe keyword completion (`<c-n>`/`<c-p>`) tries completing whatever is listed in\nthe `'complete'` option. By default, this also includes tags (which can be\nannoying) and scanning all included files (which can be very slow). If you can\nlive without these things, disable them:\n\n```vim\nset complete-=i   \" disable scanning included files\nset complete-=t   \" disable searching tags\n```\n\n## Cosmetic changes to colorschemes\n\nAlways use a dark gray statusline, no matter what colorscheme is chosen:\n\n```vim\nautocmd ColorScheme * highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE\n```\n\nThis triggers every time you use `:colorscheme ...`. If you want it to trigger\nonly for a certain colorscheme:\n\n```vim\nautocmd ColorScheme desert highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE\n```\n\nThis triggers only for `:colorscheme desert`.\n\n# Commands\n\nUseful commands that are good to know. Use `:h :<command name>` to learn more\nabout them, e.g. `:h :global`.\n\n## :global and :vglobal\n\nExecute a command on all matching lines. E.g. `:global /regexp/ print` will use\n`:print` on all lines that contain \"regexp\".\n\nFun fact: You probably all know good old grep, the filter program written by Ken\nThompson. What does it do? It prints all lines matching a certain regular\nexpression! Now guess the short form of `:global /regexp/ print`? That's right!\nIt's `:g/re/p`. Ken Thompson was inspired by vi's `:global` when he wrote grep.\n\nDespite its name, `:global` only acts on all lines by default, but it also takes\na range. Assume you want use `:delete` on all lines from the current line to the\nnext blank line (matched by the regular expression `^$`) that contain \"foo\":\n\n```vim\n:,/^$/g/foo/d\n```\n\nFor executing commands on all lines that do _not_ match a given pattern, use\n`:global!` or its alias `:vglobal` (think _inVerse_) instead.\n\n## :normal and :execute\n\nThese commands are commonly used in Vim scripts.\n\nWith `:normal` you can do normal mode mappings from the command-line. E.g.\n`:normal! 4j` will make the cursor go down 4 lines (without using any custom\nmapping for \"j\" due to the \"!\").\n\nMind that `:normal` also takes a [range](#ranges), so `:%norm! Iabc` would\nprepend \"abc\" to every line.\n\nWith `:execute` you can mix commands with expressions. Assume you edit a C\nsource file and want to switch to its header file:\n\n```vim\n:execute 'edit' fnamemodify(expand('%'), ':r') . '.h'\n```\n\nBoth commands are often used together. Assume you want to make the cursor go\ndown \"n\" lines:\n\n```vim\n:let n = 4\n:execute 'normal!' n . 'j'\n```\n\n## :redir and execute()\n\nMany commands print messages and `:redir` allows to redirect that output. You\ncan redirect to files, [registers](#registers) or variables.\n\n```vim\n:redir => var\n:reg\n:redir END\n:echo var\n:\" For fun let's also put it onto the current buffer.\n:put =var\n```\n\nIn Vim 8 there is an even shorter way:\n\n```vim\n:put =execute('reg')\n```\n\nHelp:\n\n```\n:h :redir\n:h execute()\n```\n\n# Debugging\n\n## General tips\n\nIf you encounter a strange behaviour, try reproducing it like this:\n\n```\nvim -u NONE -N\n```\n\nThis will start Vim without vimrc (thus default settings) and in nocompatible\nmode (which makes it use Vim defaults instead of vi defaults). (See `:h\n--noplugin` for other combinations of what to load at start.)\n\nIf you can still reproduce it now, it's most likely a bug in Vim itself! Report\nit to the [vim_dev](https://groups.google.com/forum/#!forum/vim_dev) mailing\nlist. Most of the time the issue won't be resolved at this time and you'll have\nto further investigate.\n\nPlugins often introduce new/changed/faulty behaviour. E.g. if it happens on\nsaving, check `:verb au BufWritePost` to get a list of potential culprits.\n\nIf you're using a plugin manager, comment them out until you find the culprit.\n\nIssue is still not resolved? If it's not a plugin, it must be your other\nsettings, so maybe your options or autocmds etc.\n\nTime to use binary search. Repeatedly split the search space in two until you\nfind the culprit line. Due to the nature of binary division, it won't take many\nsteps.\n\nIn practice, it works like this: Put the `:finish` command in the middle of your\nvimrc. Vim will skip everything after it. If it still happens, the problem is in\nthe active upper half. Move the `:finish` to the middle of _that_ half.\nOtherwise, the issue is in the inactive lower half. Move the `:finish` to the\nmiddle of _that_ half. And so on.\n\n## Verbosity\n\nAnother useful way for observing what Vim is currently doing is increasing the\nverbosity level. Currently Vim supports 9 different levels. See `:h 'verbose'`\nfor the full list.\n\n```vim\n:e /tmp/foo\n:set verbose=2\n:w\n:set verbose=0\n```\n\nThis would show all the files that get sourced, e.g. the undo file or various\nplugins that act on saving.\n\nIf you only want increase verbosity for a single command, there's also\n`:verbose`, which simply gets put in front of any other command. It takes the\nverbosity level as count and defaults to 1:\n\n```vim\n:verb set verbose\n\"  verbose=1\n:10verb set verbose\n\"  verbose=10\n```\n\nIt's very often used with its default verbosity level 1 to show where an option\nwas set last:\n\n```vim\n:verb set ai?\n\"      Last set from ~/.vim/vimrc\n```\n\nNaturally, the higher the verbosity level the more overwhelming the output. But\nfear no more, you can simply redirect the output to a file:\n\n```vim\n:set verbosefile=/tmp/foo | 15verbose echo \"foo\" | vsplit /tmp/foo\n```\n\nYou can also enable verbosity at starting time, with the `-V` option. It\ndefaults to verbosity level 10. E.g. `vim -V5`.\n\n## Profiling startup time\n\nVim startup feels slow? Time to crunch some numbers:\n\n```\nvim --startuptime /tmp/startup.log +q && vim /tmp/startup.log\n```\n\nThe first column is the most important as it shows the elapsed absolute time. If\nthere is a big jump in time between two lines, the second line is either a very\nbig file or a file with faulty VimL code that is worth investigating.\n\n## Profiling at runtime\n\nRequired [feature](#what-kind-of-vim-am-i-running): `+profile`\n\nVim provides a built-in capability for profiling at runtime and is a great way\nto find slow code in your environment.\n\nThe `:profile` command takes a bunch of sub-commands for specifying what to\nprofile.\n\nIf you want to profile _everything_, do this:\n\n    :profile start /tmp/profile.log\n    :profile file *\n    :profile func *\n    <do something in Vim>\n    :qa\n\nVim keeps the profiling information in memory and only writes it out to the\nlogfile on exit. (Neovim has fixed this using `:profile dump`).\n\nHave a look at `/tmp/profile.log`. All code that was executed during profiling\nwill be shown. Every line, how often it was executed and how much time it took.\n\nJump to the bottom of the log. Here are two different sections `FUNCTIONS SORTED\nON TOTAL TIME` and `FUNCTIONS SORTED ON SELF TIME` that are worth gold. At a\nquick glance you can see which functions are taking the longest.\n\nYou can use `:profile` during startup as well:\n\n    $ vim --cmd 'prof start prof.log | prof file * | prof func *' test.c\n    :q\n    $ tail -50 prof.log\n\n## Debugging Vim scripts\n\nIf you ever used a command-line debugger before, `:debug` will quickly feel\nfamiliar.\n\nSimply prepend `:debug` to any other command and you'll be put into debug mode.\nThat is, the execution will stop at the first line about to be executed and that\nline will be displayed.\n\nSee `:h >cont` and below for the 6 available debugger commands and note that,\nlike in gdb and similar debuggers, you can also use their short forms: `c`, `q`,\n`n`, `s`, `i`, and `f`.\n\nApart from that those, you're free to use any Vim command, e.g. `:echo myvar`,\nwhich gets executed in the context of the current position in the code.\n\nYou basically get a\n[REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) by\nsimply using `:debug 1`.\n\nIt would be a pain if you had to single-step through every single line, so of\ncourse we can define breakpoints, too. (Breakpoints are called breakpoints,\nbecause the execution stops when they're hit, thus you can simply skip code\nyou're not interested in.) See `:h :breakadd`, `:h :breakdel`, and `:h\n:breaklist` for further details.\n\nLet's assume you want to know what code is run every time you save a file:\n\n```vim\n:au BufWritePost\n\" signify  BufWritePost\n\"     *         call sy#start()\n:breakadd func *start\n:w\n\" Breakpoint in \"sy#start\" line 1\n\" Entering Debug mode.  Type \"cont\" to continue.\n\" function sy#start\n\" line 1: if g:signify_locked\n>s\n\" function sy#start\n\" line 3: endif\n>\n\" function sy#start\n\" line 5: let sy_path = resolve(expand('%:p'))\n>q\n:breakdel *\n```\n\nAs you can see, using `<cr>` will repeat the previous debugger command, `s` in\nthis case.\n\n`:debug` can be used in combination with the [verbose](#verbosity) option.\n\n## Debugging syntax files\n\nSyntax files are often the cause for slowdowns due to wrong and/or complex\nregular expressions. If the `+profile` [feature](#what-kind-of-vim-am-i-running)\nis compiled in, Vim provides the super useful `:syntime` command.\n\n```vim\n:syntime on\n\" hit <c-l> a few times to redraw the window which causes the syntax rules to get applied again\n:syntime off\n:syntime report\n```\n\nThe output contains important metrics. E.g. you can see which regexp takes too\nlong and should be optimized or which regexps are used all the time but never\neven match.\n\nSee `:h :syntime`.\n\n# Miscellaneous\n\n## Additional resources\n\n| Resource | Description |\n|----------|-------------|\n| [Seven habits of effective text editing](http://www.moolenaar.net/habits.html) | By Bram Moolenaar, the author of Vim. |\n| [Seven habits of effective text editing 2.0 (PDF)](http://www.moolenaar.net/habits_2007.pdf) | See above. |\n| [IBM DeveloperWorks: Scripting the Vim editor](http://www.ibm.com/developerworks/views/linux/libraryview.jsp?sort_order=asc&sort_by=Title&search_by=scripting+the+vim+editor) | Five-part series on Vim scripting. |\n| [Learn Vimscript the Hard Way](http://learnvimscriptthehardway.stevelosh.com) | Develop a Vim plugin from scratch. |\n| [Practical Vim (2nd Edition)](https://pragprog.com/titles/dnvim2/practical-vim-second-edition) | Hands down the best book about Vim. |\n| [Why, oh WHY, do those #?@! nutheads use vi?](http://www.viemu.com/a-why-vi-vim.html) | Common misconceptions explained. |\n| [Your problem with Vim is that you don't grok vi](http://stackoverflow.com/a/1220118) | Concise, informative and correct. A real gem. |\n\n#### Screencasts\n\n- [vimcasts.org](http://vimcasts.org/episodes/archive)\n- [By wincent](https://www.youtube.com/channel/UCXPHFM88IlFn68OmLwtPmZA)\n- [By Derek Wyatt](http://derekwyatt.org/vim/tutorials/index.html)\n\n## Vim distributions\n\nVim distributions are bundles of custom settings and plugins for Vim.\n\nMore advanced users know how to configure their editor anyway, so distributions\nare mostly targeted at beginners. If you think about that, it's quite\nparadoxical though: Making it easier by adding even more things to learn about?\n\nI know that many people don't want to spend hours and hours on customizing an\neditor (and actually you never stop customizing your vimrc when you finally got\nhooked), but eventually you only get efficient in Vim when you take the time to\nlearn it properly.\n\nRepeat after me: \"A programmer should know their tools.\"\n\nAnyway, if you know what you're doing, you might draw some inspiration from\nlooking at a few distributions:\n\n- [cream](http://cream.sourceforge.net)\n- [janus](https://github.com/carlhuda/janus.git)\n- [spacevim](https://github.com/SpaceVim/SpaceVim)\n- [spf13](https://github.com/spf13/spf13-vim)\n\n## Standard plugins\n\nMany people are surprised by the fact that Vim comes with a handful of standard\nplugins. Some get loaded by default (`:e $VIMRUNTIME/plugin`) and some are not\n(`:e $VIMRUNTIME/pack/dist/opt`). Read `:h pack-add` on how to source the\nlatter.\n\nMost of the plugins that get loaded by default will never get used, though.\nDisable them as you see fit. They will still be shown as sourced\n(`:scriptnames`), but only the first lines actually get read before Vim bails\nout. No further code (mappings, commands, logic) will be processed.\n\n| Plugin     | Disable it using..                  | Help |\n|------------|-------------------------------------|------|\n| 2html      | `let g:loaded_2html_plugin = 1`     | `:h 2html` |\n| getscript  | `let g:loaded_getscriptPlugin = 1`  | `:h pi_getscript` |\n| gzip       | `let g:loaded_gzip = 1`             | `:h pi_gzip` |\n| logipat    | `let g:loaded_logipat = 1`          | `:h pi_logipat` |\n| matchparen | `let g:loaded_matchparen = 1`       | `:h pi_paren` |\n| netrw      | `let g:loaded_netrwPlugin = 1`      | `:h pi_netrw` |\n| rrhelper   | `let g:loaded_rrhelper = 1`         | `:e $VIMRUNTIME/plugin/rrhelper.vim` |\n| spellfile  | `let g:loaded_spellfile_plugin = 1` | `:h spellfile.vim` |\n| tar        | `let g:loaded_tarPlugin = 1`        | `:h pi_tar` |\n| vimball    | `let g:loaded_vimballPlugin = 1`    | `:h pi_vimball` |\n| zip        | `let g:loaded_zipPlugin = 1`        | `:h pi_zip` |\n\n## Map CapsLock to Control\n\nCapsLock belongs to the most useless keys on your keyboard, but it's much easier\nto reach than the Control key, since it lies on your [home\nrow](https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-homerow.png).\nMapping CapsLock to Control is a great way to prevent or at least reduce\n[RSI](https://de.wikipedia.org/wiki/Repetitive-Strain-Injury-Syndrom) if you\nprogram a lot.\n\nAttention: When you get used to it, you can't live without it anymore.\n\n**macOS**:\n\n`System Preferences -> Keyboard -> Keyboard Tab -> Modifier Keys`. Change\n\"CapsLock\" to \"Control\".\n\n**Linux**:\n\nTo change the keys in X, put this in your `~/.xmodmap`:\n\n    remove Lock = Caps_Lock\n    keysym Caps_Lock = Control_L\n    add Control = Control_L\n\nAfterwards source it via `$ xmodmap ~/.xmodmap`.\n\nAn alternative would be using [caps2esc](https://github.com/oblitum/caps2esc) or\n[xcape](https://github.com/alols/xcape).\n\n**Windows**:\n\nSee [superuser.com: Map Caps-Lock to Control in Windows\n8.1](http://superuser.com/questions/764782/map-caps-lock-to-control-in-windows-8-1).\n\n## Generating HTML from buffer\n\nGenerate HTML from any buffer using `:TOhtml` from the 2html [standard\nplugin](#standard-plugins). The output can be used for printing or easy web\npublishing.\n\nThe command creates a new buffer of the same name with `.html` appended. The\ncolors are the same as seen in Vim. They depend on the\n[colorscheme](#colorschemes).\n\nThe plugin knows several options to finetune the output, e.g. for setting the\nencoding and font.\n\nSee `:h :TOhtml`.\n\n## Easter eggs\n\n| Command   | Message |\n|-----------|---------|\n| `:Ni!` | `Do you demand a shrubbery?` |\n| `:h 'sm'` | `NOTE: Use of the short form is rated PG.` |\n| `:h 42` | `What is the meaning of life, the universe and everything? Douglas Adams, the only person who knew what this question really was about is now dead, unfortunately.  So now you might wonder what the meaning of death is...` |\n| `:h UserGettingBored` | `When the user presses the same key 42 times. Just kidding! :-)` |\n| `:h bar` | `Ceci n'est pas une pipe.` |\n| `:h holy-grail` | `You found it, Arthur!` |\n| `:h map-modes` | `:nunmap can also be used outside of a monastery.` |\n| `:help!` | `E478: Don't panic!` (Glitch? When used in a help buffer (`buftype=help`) this works like `:h help.txt` instead.) |\n| `:smile` | Try it out yourself. ;-) Added in 7.4.1005. |\n| `:hi!` | `Greetings, Vim user!` |\n\n## Why hjkl for navigation?\n\nWhen [Bill Joy](https://en.wikipedia.org/wiki/Bill_Joy) created\n[vi](https://en.wikipedia.org/wiki/Vi), a predecessor of Vim, he did it on a\n[ADM-3A](https://en.wikipedia.org/wiki/ADM-3A) which had no extra cursor buttons\nbut used, you might already guessed it, hjkl instead.\n\nKeyboard layout: [click](https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-adm-3a-layout.jpg)\n\nThis also shows why `~` is used to denote the home directory on Unix systems.\n\n# Common problems\n\n## Editing small files is slow\n\nThere are two things which can have a huge impact on performance:\n\n1. Complex **regular expressions**. Particular the Ruby syntax file caused\n   people to have slowdowns in the past. (Also see [Debugging syntax files](#debugging-syntax-files).)\n2. **Screen redraws**. Some features force all lines to redraw.\n\n| Typical culprit | Why? | Solution? |\n|-----------------|------|-----------|\n| `:set cursorline`        | Causes all lines to redraw. | `:set nocursorline` |\n| `:set cursorcolumn`      | Causes all lines to redraw. | `:set nocursorcolumn` |\n| `:set relativenumber`    | Causes all lines to redraw. | `:set norelativenumber` |\n| `:set foldmethod=syntax` | If the syntax file is slow already, this makes it even worse. | `:set foldmethod=manual`, `:set foldmethod=marker` or [FastFold](https://github.com/Konfekt/FastFold) |\n| `:set synmaxcol=3000`    | Due to internal representation, Vim has problems with long lines in general. Highlights columns till column 3000. | `:set synmaxcol=200` |\n| matchparen.vim           | Loaded by default. Uses regular expressions to find the accompanying parenthesis. | Disable plugin: `:h matchparen` |\n\n**NOTE**: You only need to do this if you experience actual performance\ndrawbacks. In most cases using the things mentioned above is absolutely fine.\n\n## Editing huge files is slow\n\nThe biggest issue with big files is, that Vim reads the whole file at once. This\nis done due to how buffers are represented internally.\n([Discussion on vim_dev@](https://groups.google.com/forum/#!topic/vim_dev/oY3i8rqYGD4/discussion))\n\nIf you only want to read, `tail hugefile | vim -` is a good workaround.\n\nIf you can live without syntax, settings and plugins for the moment:\n\n```\n$ vim -u NONE -N\n```\n\nThis should make navigation quite a lot faster, especially since no expensive\nregular expressions for syntax highlighting are used. You should also tell Vim\nnot to use swapfiles and viminfo files to avoid long delays on writing:\n\n```\n$ vim -n -u NONE -i NONE -N\n```\n\nPutting it in a nutshell, try to avoid using Vim when intending to write really\nhuge files. :\\\n\n## Bracketed paste (or why do I have to set 'paste' all the time?)\n\nBracketed paste mode allows terminal emulators to distinguish between typed text\nand pasted text.\n\nDid you ever tried pasting code into Vim and afterwards everything seemed messed\nup?\n\nThis only happens if you paste via `cmd+v`, `shift-insert`, `middle-click` etc.\nbecause then you're just throwing text at the terminal emulator. Vim doesn't\nknow that you just pasted the text, it thinks you're an extremely fast typist.\nAccordingly, it tries to indent the lines and fails.\n\nObviously this is not an issue, if you paste using Vim's registers, e.g. `\"+p`,\nbecause then Vim knows that you're actually pasting.\n\nTo workaround this, you have to `:set paste`, so it gets pasted as-is. See `:h\n'paste'` and `:h 'pastetoggle'`.\n\nIf you're fed up with toggling `'paste'` all the time, have a look at this fine\nplugin that does it for you:\n[bracketed-paste](https://github.com/ConradIrwin/vim-bracketed-paste).\n\nAdditional read from the same author as the plugin:\n[here](http://cirw.in/blog/bracketed-paste).\n\n**Neovim**: Neovim tries to make all of this much more seamless and sets\nbracketed paste mode automatically if the terminal emulator supports it.\n\n## Delays when using escape key in terminal\n\nIf you live in the command-line, you probably use a so-called _terminal\nemulator_ like xterm, gnome-terminal, iTerm2, etc. (opposed to a real\n[terminal](https://en.wikipedia.org/wiki/Computer_terminal)).\n\nLike their ancestors, terminal emulators use [escape\nsequences](https://en.wikipedia.org/wiki/Escape_sequence) (or _control\nsequences_) to control things like moving the cursor, changing text colors, etc.\nThey're simply strings of ASCII characters starting with an escape character\n(displayed in [caret notation](https://en.wikipedia.org/wiki/Caret_notation) as\n`^[`). When such a string arrives, the terminal emulator looks up the\naccompanying action in the [terminfo](https://en.wikipedia.org/wiki/Terminfo)\ndatabase.\n\nTo make the problem clearer, I'll explain mapping timeouts first. They always\nhappen when there's ambiguity between mappings:\n\n```vim\n:nnoremap ,a  :echo 'foo'<cr>\n:nnoremap ,ab :echo 'bar'<cr>\n```\n\nBoth mappings work as expected, but when typing `,a`, there will be a delay of 1\nsecond, because Vim waits whether the user keys in another `b` or not.\n\nEscape sequences pose the same problem:\n\n- `<esc>` is used a lot for returning to normal mode or quitting an action.\n- Cursor keys are encoded using escape sequences.\n- Vim expects <kbd>Alt</kbd> (also called _Meta key_) to send a proper 8-bit\n  encoding with the high bit set, but many terminal emulators don't support it\n  (or don't enable it by default) and send an escape sequence instead.\n\nYou can test the above like this: `vim -u NONE -N` and type `i<c-v><left>` and\nyou'll see a sequence inserted that starts with `^[` which denotes the escape\ncharacter.\n\nPutting it in a nutshell, Vim has a hard time distinguishing between a typed\n`<esc>` character and a proper escape sequence.\n\nBy default, Vim uses `:set timeout timeoutlen=1000`, so it delays on ambiguity\nof mappings _and_ key codes by 1 second. This is a sane value for mappings, but\nyou can define the key code timeout on its own which is the most common\nworkaround for this entire issue:\n\n```vim\nset timeout           \" for mappings\nset timeoutlen=1000   \" default value\nset ttimeout          \" for key codes\nset ttimeoutlen=10    \" unnoticeable small value\n```\n\nUnder `:h ttimeout` you find a small table showing the relationship between\nthese options.\n\nIf you're using tmux between Vim and your terminal emulator, also put this in\nyour `~/.tmux.conf`:\n\n```tmux\nset -sg escape-time 0\n```\n\n## Function search undo\n\n- A search pattern in a command (`/`, `:substitute`, ...) changes the \"last used\n  search pattern\". (It's saved in the `/` register; print it with `:echo @/`).\n- A simple text change can be redone with `.`. (It's saved in the `.` register;\n  print it with `:echo @.`).\n\nBoth things are _not_ the case, if you do them from a function, though! Thus you\ncan't easily highlight words from a function or redo the text changes made by\nit.\n\nHelp: `:h function-search-undo`\n\n# Technical quirks\n\n## Newline used for NUL\n\nNUL characters (`\\0`) in a file, are stored as newline (`\\n`) in memory and\ndisplayed in a buffer as `^@`.\n\nSee `man 7 ascii` and `:h NL-used-for-Nul` for more information.\n\n# Terminology\n\n## Vim script? Vimscript? VimL?\n\n`Vim script`, `Vimscript`, and `VimL` all refer to the same thing: The\nprogramming language used for scripting Vim. Even though\n[8.0.360](https://github.com/vim/vim/commit/b544f3c81f1e6a50322855681ac266ffaa8e313c)\nchanged all references from `VimL` to `Vim script`, which can now be considered\nthe official term, `VimL` is still widespread all over the internet.\n\nNo matter which term you use, everyone will understand it.\n"
}